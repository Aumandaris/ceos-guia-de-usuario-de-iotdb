API nativa de Java
#
Dependencias

    JDK> = 1.8
    Maven> = 3.6

#
Instalación

En el directorio raíz:

    mvn instalación limpia -pl sesión -am -DskipTests

#
Uso de la API nativa de Java de IoTDB con Maven

<dependencias>
    <dependencia>
      <groupId> org.apache.iotdb </groupId>
      <artifactId> sesión de iotdb </artifactId>
      <versión> 0.12.0 </version>
    </dependencia>
</dependencias>

#
API nativas

Aquí mostramos las interfaces de uso común y sus parámetros en la API nativa:

    Inicializar una sesión

Sesión (String host, int rpcPort)

Sesión (cadena de host, cadena rpcPort, cadena de nombre de usuario, cadena de contraseña)

Sesión (String host, int rpcPort, String username, String contraseña)

    Abrir una sesión

Session.open ()

    Cerrar una sesión

Session.close ()

    Establecer grupo de almacenamiento

void setStorageGroup (String storageGroupId)

    Eliminar uno o varios grupos de almacenamiento

void deleteStorageGroup (String storageGroup)
void deleteStorageGroups (List <String> storageGroups)

    Crea una o varias series temporales

void createTimeseries (Ruta de cadena, TSDataType dataType,
      Codificación TSEncoding, compresor CompressionType, accesorios Map <String, String>,
      Etiquetas Map <String, String>, atributos Map <String, String>, String MeasureAlias)
      
void createMultiTimeseries (List <String> rutas, List <TSDataType> dataTypes,
      Lista <TSEncoding> codificaciones, Lista <CompressionType> compresores,
      Lista <Mapa <Cadena, Cadena >> propsList, Lista <Mapa <Cadena, Cadena >> tagsList,
      List <Map <String, String >> attributeList, List <String> mediciónAliasList)

    Eliminar una o varias series temporales

void deleteTimeseries (ruta de cadena)
void deleteTimeseries (List <String> rutas)

    Eliminar datos antes o iguales a una marca de tiempo de una o varias series de tiempo

void deleteData (ruta de cadena, tiempo largo)
void deleteData (List <String> rutas, mucho tiempo)

    Insertar un registro, que contiene varios valores de medición de un dispositivo en una marca de tiempo. Sin la información de tipos, el servidor tiene que realizar una inferencia de tipos, lo que puede costar algo de tiempo.

void insertRecord (String deviceId, largo tiempo, List <String> medidas, List <String> valores)

    Inserte una tableta, que son varias filas de un dispositivo, cada fila tiene las mismas medidas

void insertTablet (tableta)

    Insertar múltiples tabletas

void insertTablets (tableta Map <String, Tablet>)

    Insertar varios registros. Sin la información de tipos, el servidor tiene que realizar una inferencia de tipos, lo que puede costar algo de tiempo.

void insertRecords (List <String> deviceIds, List <Long> veces,
                   List <List <String>> medicionesList, List <List <String>> valuesList)

    Insertar un registro, que contiene varios valores de medición de un dispositivo en una marca de tiempo. Con la información de tipos, el servidor no necesita hacer inferencias de tipos, lo que conduce a un mejor rendimiento.

void insertRecord (String deviceId, largo tiempo, List <String> medidas,
   List <TSDataType> tipos, List <Object> valores)

    Insertar varios registros. Con la información de tipos, el servidor no necesita hacer inferencias de tipos, lo que conduce a un mejor rendimiento.

void insertRecords (List <String> deviceIds, List <Long> veces,
    List <List <String>> actionsList, List <List <TSDataType>> typesList,
    Lista <Lista <Objeto>> lista de valores)

    Inserte varios registros que pertenezcan al mismo dispositivo. Con la información de tipos, el servidor no necesita hacer inferencias de tipos, lo que conduce a un mejor rendimiento.

void insertRecordsOfOneDevice (String deviceId, List <Long> veces,
    List <List <String>> actionsList, List <List <TSDataType>> typesList,
    Lista <Lista <Objeto>> lista de valores)

    Consulta de datos brutos. El intervalo de tiempo incluye startTime y excluye endTime

SessionDataSet executeRawDataQuery (List <String> rutas, startTime largo, endTime largo)

    Ejecutar declaración de consulta

SessionDataSet executeQueryStatement (String sql)

    Ejecutar declaración sin consulta

void executeNonQueryStatement (String sql)

#
API nativas para perfilar el costo de la red

    Pruebe el costo de la red y del cliente de insertRecords. Este método NO inserta datos en la base de datos y el servidor simplemente regresa después de aceptar la solicitud, este método debe usarse para probar otros costos de tiempo en el cliente

void testInsertRecords (List <String> deviceIds, List <Long> veces,
              List <List <String>> medicionesList, List <List <String>> valuesList)

o

void testInsertRecords (List <String> deviceIds, List <Long> veces,
    List <List <String>> actionsList, List <List <TSDataType>> typesList,
    Lista <Lista <Objeto>> lista de valores)

    Pruebe la red y el costo del cliente de insertRecordsOfOneDevice. Este método NO inserta datos en la base de datos y el servidor simplemente regresa después de aceptar la solicitud, este método debe usarse para probar otros costos de tiempo en el cliente

void testInsertRecordsOfOneDevice (String deviceId, List <Long> veces,
    List <List <String>> actionsList, List <List <TSDataType>> typesList,
    Lista <Lista <Objeto>> lista de valores)

    Pruebe la red y el costo del cliente de insertRecord. Este método NO inserta datos en la base de datos y el servidor simplemente regresa después de aceptar la solicitud, este método debe usarse para probar otros costos de tiempo en el cliente

prueba vacía rtRecord (String deviceId, largo tiempo, List <String> medidas, List <String> valores)

o

void testInsertRecord (String deviceId, largo tiempo, List <String> mediciones,
    List <TSDataType> tipos, List <Object> valores)

    Pruebe la red y el costo del cliente de insertTablet. Este método NO inserta datos en la base de datos y el servidor simplemente regresa después de aceptar la solicitud, este método debe usarse para probar otros costos de tiempo en el cliente

prueba de vacíoInsertTablet (tableta)

#
Ejemplo de codificación

Para obtener más información de las siguientes interfaces, consulte session / src / main / java / org / apache / iotdb / session / Session.java

El código de muestra del uso de estas interfaces se encuentra en example / session / src / main / java / org / apache / iotdb / SessionExample.java, que proporciona un ejemplo de cómo abrir una sesión de IoTDB, ejecutar una inserción por lotes.
#
Grupo de sesiones para API nativa

Proporcionamos un grupo de conexiones (`SessionPool) para la API nativa. Usando la interfaz, necesita definir el tamaño de la piscina.

Si no puede obtener una conexión de sesión en 60 segundos, hay un registro de advertencia, pero el programa se bloqueará.

Si una sesión ha finalizado una operación, se volverá a poner en el grupo automáticamente. Si se interrumpe la conexión de una sesión, la sesión se eliminará automáticamente y el grupo intentará crear una nueva sesión y rehacer la operación.

Para operaciones de consulta:

    Cuando se usa SessionPool para consultar datos, el conjunto de resultados es SessionDataSetWrapper;
    Dado un SessionDataSetWrapper, si no ha escaneado todos los datos que contiene y deja de usarlo, debe llamar a SessionPool.closeResultSet (envoltorio) manualmente;
    Cuando llama a hasNext () y next () de un SessionDataSetWrapper y hay una excepción, entonces debe llamar a SessionPool.closeResultSet (envoltorio) manualmente;
    Puede llamar a getColumnNames () de SessionDataSetWrapper para obtener los nombres de columna del resultado de la consulta;

Ejemplos: session / src / test / java / org / apache / iotdb / session / pool / SessionPoolTest.java

O ejemplo / session / src / main / java / org / apache / iotdb / SessionPoolExample.java
#
Nuevas interfaces

void abierto (booleano enableRPCCompression)

Abra una sesión, con un parámetro para especificar si habilitar la compresión RPC. Preste atención a que este estado de compresión RPC del cliente debe cumplir con el estado del servidor IoTDB

void insertRecord (String deviceId, largo tiempo, List <String> medidas,
      List <TSDataType> tipos, List <Object> valores)

Inserte un registro, de manera que el usuario tenga que proporcionar la información de tipo de cada medición, que es diferente de la interfaz original insertRecord (). Los valores deben proporcionarse en sus tipos primitivos. Esta interfaz es más competente que la que no tiene parámetros de tipo.

void insertRecords (List <String> deviceIds, List <Long> veces, List <List <String>> MeasuringList,
                   List <List <TSDataType>> typesList, List <List <Object>> valuesList)

Inserte varios registros con parámetros de tipo. Esta interfaz es más competente que la que no tiene parámetros de tipo.

void insertTablet (tableta, ordenado por booleano)

Una interfaz insertTablet () adicional que proporciona un parámetro "ordenado" que indica si la tableta está en orden. Una tableta clasificada puede acelerar el proceso de inserción.

void insertTablets (Map <String, Tablet> tabletas)

Un nuevo insertTablets () para insertar varias tabletas.

void insertTablets (Tabletas Map <String, Tablet>, ordenadas de forma booleana)

insertTablets () con un parámetro adicional "ordenado".

void testInsertRecord (String deviceId, long time, List <String> medidas, List <TSDataType> tipos,
                      Lista de valores de <Objeto>)
void testInsertRecords (List <String> deviceIds, List <Long> veces, List <List <String>> MeasuringList,
                      List <List <TSDataType>> typesList, List <List <Object>> valuesList)
void testInsertTablet (tableta, ordenado de forma booleana)
void testInsertTablets (Map <String, Tablet> tabletas)
void testInsertTablets (Map <String, Tablet> tabletas, ordenadas por booleano)

Las interfaces anteriores se agregaron recientemente para probar la capacidad de respuesta de las nuevas interfaces de inserción.

void createTimeseries (ruta de cadena, TSDataType dataType, codificación TSEncoding, compresor CompressionType,
                      Map <String, String> props, Map <String, String> etiquetas, atributos Map <String, String>,
                      Medición de cadenas Alias)

Cree una serie temporal con ruta, tipo de datos, codificación y compresión. Además, los usuarios pueden proporcionar accesorios, etiquetas, atributos y alias de medición。

void createMultiTimeseries (List <String> rutas, List <TSDataType> dataTypes, List <TSEncoding> codificaciones,
                           List <CompressionType> compresores, List <Map <String, String >> propsList,
                           Lista <Mapa <Cadena, Cadena >> tagsList, Lista <Mapa <Cadena, Cadena >> attributeList,
                           List <String> MeasureAliasList)

Crea múltiples series temporales con un solo método. Los usuarios pueden proporcionar accesorios, etiquetas, atributos y alias de medición, así como información detallada sobre series de tiempo.

boolean checkTimeseriesExists (ruta de cadena)

Agregue un método para verificar si elExiste una serie temporal específica.

Sesión pública (String host, int rpcPort, String username, String contraseña,
       boolean isEnableCacheLeader)

Abre una sesión y especifica si la caché de Leader está habilitada. Tenga en cuenta que esta interfaz mejora el rendimiento para IoTDB distribuido, pero agrega menos costos para el cliente para IoTDB independiente.
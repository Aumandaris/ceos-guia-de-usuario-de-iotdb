<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Función Definida por el Usuario (UDF) :: Guía de Usuario de IoTDB</title>
    <link rel="canonical" href="https://aumandaris.github.io/ceos-guia-de-usuario-de-iotdb/ceos-guia-de-usuario-de-iotdb/0.12.x/index.html/ceos-guia-de-usuario-de-iotdb/0.12.x/udf-funcion-definida-por-el-usuario/udf-funcion-definida-por-el-usuario.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://aumandaris.github.io/ceos-guia-de-usuario-de-iotdb/ceos-guia-de-usuario-de-iotdb/0.12.x/index.html">
        <img src="/ceos-guia-de-usuario-de-iotdb/ceos-guia-de-usuario-de-iotdb/0.12.x/_images/ceos-logo.png" width="40">
        <span>Guía de Usuario de IoTDB<span>     
      </a>
    </div>
    <div id="topbar-nav" class="navbar-menu">
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ceos-guia-de-usuario-de-iotdb" data-version="0.12.x">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Guía de Usuario de IoTDB</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Introducción a IoTDB</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduccion-a-iotdb/que-es-iotdb.html">Qué es IoTDB</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduccion-a-iotdb/arquitectura.html">Arquitectura</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#introduccion-a-iotdb/escenario.adoc">Escenarios</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduccion-a-iotdb/caracteristicas.html">Características</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduccion-a-iotdb/publicacion.html">Publicación</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Inicio Rápido</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../inicio-rapido/inicio-rapido.html">Inicio Rápido</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../inicio-rapido/configuracion-de-ruta-de-almacenamiento.html">Configuración de Ruta de Almacenamiento</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../inicio-rapido/obtener-archivos-binarios-de-iotdb.html">Obtener Archivos Binarios de IoTDB</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Concepto de Datos</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepto-de-datos/modelo-de-datos-y-terminologia.html">Modelo de Datos y Terminología</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepto-de-datos/tipo-de-datos.html">Tipo de Datos</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepto-de-datos/codificacion.html">Codificación</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepto-de-datos/compresion.html">Compresión</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepto-de-datos/sdt.html">SDT</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Interfaz de Línea de Comandos</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../interfaz-de-linea-de-comandos/interfaz-de-linea-de-comandos.html">Interfaz de Línea de Comandos</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Gestión de la Administración</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../gestion-de-la-administracion/administracion.html">Administración</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Lenguaje IoTDB-SQL</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../lenguaje-iotdb-sql/ddl-lenguaje-de-definicion-de-datos.html">DDL (Lenguaje de Definición de Datos)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../lenguaje-iotdb-sql/dml-lenguaje-de-manipulacion-de-datos.html">DML (Lenguaje de Manipulación de Datos)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../lenguaje-iotdb-sql/comando-de-mantenimiento.html">Comando de Mantenimiento</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">API (Interfaz de Programación de Aplicaciones)</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../api-interfaz-de-programacion-de-aplicaciones/jdbc.html">JDBC</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../api-interfaz-de-programacion-de-aplicaciones/api-nativa.html">API Nativa</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../api-interfaz-de-programacion-de-aplicaciones/otros-lenguajes.html">Otros Lenguajes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../api-interfaz-de-programacion-de-aplicaciones/api-tsfile.html">API TsFile</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Guía de Usuario de IoTDB</span>
    <span class="version">0.12.x</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Guía de Usuario de IoTDB</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">0.12.x</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Guía de Usuario de IoTDB</a></li>
    <li><a href="udf-funcion-definida-por-el-usuario.html">Función Definida por el Usuario (UDF)</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/Aumandaris/ceos-guia-de-usuario-de-iotdb/edit/master/modules/ROOT/pages/udf-funcion-definida-por-el-usuario/udf-funcion-definida-por-el-usuario.adoc">Editar esta página</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Función Definida por el Usuario (UDF)</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>IoTDB proporciona una variedad de funciones integradas para satisfacer sus necesidades informáticas, y también puede crear funciones definidas por el usuario para satisfacer más necesidades informáticas.</p>
</div>
<div class="paragraph">
<p>Este documento describe cómo escribir, registrar y usar una UDF.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_tipos_de_udf"><a class="anchor" href="#_tipos_de_udf"></a>Tipos de UDF</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En IoTDB, puede expandir dos tipos de UDF:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clase UDF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Descripción</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDTF （Función de Generación de Series de Tiempo Definida por el Usuario）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Este tipo de función puede tomar <strong>varias</strong> series de tiempo como entrada y generar una serie de tiempo, que puede tener cualquier número de puntos de datos.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDAF （Función de Agregación Definida por el Usuario）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">En desarrollo.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_dependencias_de_desarrollo_de_udf"><a class="anchor" href="#_dependencias_de_desarrollo_de_udf"></a>Dependencias de Desarrollo de UDF</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Si usa [Maven], puede buscar las dependencias de desarrollo que se enumeran a continuación desde el [repositorio de Maven]. Tenga en cuenta que debe seleccionar la misma versión de dependencia que la versión del servidor IoTDB de destino para el desarrollo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-XML hljs" data-lang="XML">&lt;dependency&gt;
  &lt;groupId&gt;org.apache.iotdb&lt;/groupId&gt;
  &lt;artifactId&gt;iotdb-server&lt;/artifactId&gt;
  &lt;version&gt;0.12.0-SNAPSHOT&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_udtf_función_de_generación_de_series_de_tiempo_definida_por_el_usuario"><a class="anchor" href="#_udtf_función_de_generación_de_series_de_tiempo_definida_por_el_usuario"></a>UDTF （Función de Generación de Series de Tiempo Definida por el Usuario）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Para escribir una UDTF, debe heredar la clase <code>org.apache.iotdb.db.query.udf.api.UDTF</code> y, al menos, implementar el método <code>beforeStart</code> y un método <code>transform</code>.</p>
</div>
<div class="paragraph">
<p>La siguiente tabla muestra todas las interfaces disponibles para la implementación del usuario.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Definición de Interfaz</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Descripción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requerido para Implementar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void validate(UDFParameterValidator validator) throws Exception</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Este método se utiliza principalmente para validar <code>UDFParameters</code> y se ejecuta antes de que se llame a <code>beforeStart(UDFParameters,UDTFConfigurations)</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">El método de inicialización para llamar al comportamiento de inicialización definido por el usuario antes de que una UDTF procese los datos de entrada. Cada vez que un usuario ejecuta una consulta UDTF, el marco construirá una nueva instancia de UDF y se llamará a <code>beforeStart</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requerido</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void transform(Row row, PointCollector collector) throws Exception</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Este método de procesamiento de datos se llamará cuando elija utilizar la estrategia <code>RowByRowAccessStrategy</code> (establecida en <code>beforeStart</code>) para consumir datos sin procesar. Los datos de entrada se pasan por <code>Row</code> y el resultado de la transformación debe ser generado por <code>PointCollector</code>. Debe llamar al método de recopilación de datos proporcionado por <code>collector</code> para determinar los datos de salida.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requerido para implementar al menos un método <code>transform</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void transform(RowWindow rowWindow, PointCollector collector) throws Exception</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Este método es llamado por el framework. Este método de procesamiento de datos se llamará cuando elija utilizar la estrategia <code>SlidingSizeWindowAccessStrategy</code> o <code>SlidingTimeWindowAccessStrategy</code> (establecida en <code>beforeStart</code>) para consumir datos sin procesar. <code>RowWindow</code> pasa los datos de entrada y <code>PointCollector</code> debe generar el resultado de la transformación. Debe llamar al método de recopilación de datos proporcionado por <code>collector</code> para determinar los datos de salida.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requerido para implementar al menos un método de transformación</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void terminate(PointCollector collector) throws Exception</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Este método es llamado por el framework.
Este método se llamará una vez después de que se hayan ejecutado todas las llamadas de <code>transform</code>. En una única consulta UDF, este método solo se llamará una vez. Debe llamar al método de recopilación de datos proporcionado por <code>collector</code> para determinar los datos de salida.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void beforeDestroy()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">El framework llama a este método después de que se procesan los últimos datos de entrada, y solo se llamará una vez en el ciclo de vida de cada instancia de UDF.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opcional</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>En el ciclo de vida de una instancia de UDTF, la secuencia de llamada de cada método es la siguiente:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>void validate(UDFParameterValidator validator) throws Exception</p>
</li>
<li>
<p>void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception</p>
</li>
<li>
<p>void transform(Row row, PointCollector collector) throws Exception or void transform(RowWindow rowWindow, PointCollector collector) throws Exception</p>
</li>
<li>
<p>void terminate(PointCollector collector) throws Exception</p>
</li>
<li>
<p>void beforeDestroy()</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Tenga en cuenta que cada vez que el marco ejecuta una consulta UDTF, se construirá una nueva instancia de UDF. Cuando finalice la consulta, se destruirá la instancia correspondiente. Por lo tanto, los datos internos de las instancias en diferentes consultas UDTF (incluso en la misma instrucción SQL) están aislados. Puede mantener algunos datos de estado en la UDTF sin tener en cuenta la influencia de la simultaneidad y otros factores.</p>
</div>
<div class="paragraph">
<p>El uso de cada interfaz se describirá en detalle a continuación.</p>
</div>
<div class="sect2">
<h3 id="_void_validateudfparametervalidator_validator_throws_exception"><a class="anchor" href="#_void_validateudfparametervalidator_validator_throws_exception"></a>void validate(UDFParameterValidator validator) throws Exception</h3>
<div class="paragraph">
<p>El método <code>validate</code> se utiliza para validar los parámetros ingresados ​​por el usuario.</p>
</div>
<div class="paragraph">
<p>En este método, puede limitar el número y los tipos de series de tiempo de entrada, verificar los atributos de la entrada del usuario o realizar cualquier verificación personalizada.</p>
</div>
<div class="paragraph">
<p>Consulte el Javadoc para conocer el uso de <code>UDFParameterValidator</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_void_beforestartudfparameters_parameters_udtfconfigurations_configurations_throws_exception"><a class="anchor" href="#_void_beforestartudfparameters_parameters_udtfconfigurations_configurations_throws_exception"></a>void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception</h3>
<div class="paragraph">
<p>Este método se utiliza principalmente para personalizar UDTF. En este método, el usuario puede hacer las siguientes cosas:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Utilice UDFParameters para obtener las rutas de la serie temporal y analizar los atributos del par clave-valor ingresados ​​por el usuario.</p>
</li>
<li>
<p>Configure la estrategia para acceder a los datos sin procesar y configure el tipo de datos de salida en UDTFConfigurations.</p>
</li>
<li>
<p>Cree recursos, como establecer conexiones externas, abrir archivos, etc.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_udfparameters"><a class="anchor" href="#_udfparameters"></a>UDFParameters</h4>
<div class="paragraph">
<p><code>UDFParameters</code> se utiliza para analizar parámetros UDF en sentencias SQL (la parte entre paréntesis después del nombre de la función UDF en SQL). Los parámetros de entrada tienen dos partes. La primera parte son las rutas (medidas) y sus tipos de datos de la serie temporal que la UDF necesita procesar, y la segunda parte son los atributos del par clave-valor para la personalización. Solo la segunda parte puede estar vacía.</p>
</div>
<div class="paragraph">
<p>Ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-SQL hljs" data-lang="SQL">SELECT UDF(s1, s2, 'key1'='iotdb', 'key2'='123.45') FROM root.sg.d;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Uso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java">void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception {
  // parameters
	for (PartialPath path : parameters.getPaths()) {
    TSDataType dataType = parameters.getDataType(path);
  	// do something
  }
  String stringValue = parameters.getString("key1"); // iotdb
  Float floatValue = parameters.getFloat("key2"); // 123.45
  Double doubleValue = parameters.getDouble("key3"); // null
  int intValue = parameters.getIntOrDefault("key4", 678); // 678
  // do something

  // configurations
  // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_udtfconfigurations"><a class="anchor" href="#_udtfconfigurations"></a>UDTFConfigurations</h4>
<div class="paragraph">
<p>Debe utilizar <code>UDTFConfigurations</code> para especificar la estrategia utilizada por UDF para acceder a los datos sin procesar y el tipo de secuencia de salida.</p>
</div>
<div class="paragraph">
<p>Uso:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-Java hljs" data-lang="Java">void beforeStart(UDFParameters parameters, UDTFConfigurations configurations) throws Exception {
  // parameters
  // ...

  // configurations
  configurations
    .setAccessStrategy(new RowByRowAccessStrategy())
    .setOutputDataType(TSDataType.INT32);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>El método <code>setAccessStrategy</code> se usa para establecer la estrategia de UDF para acceder a los datos sin procesar, y el método <code>setOutputDataType</code> se usa para establecer el tipo de datos de la secuencia de salida.
#</p>
</div>
<div class="sect4">
<h5 id="_setaccessstrategy"><a class="anchor" href="#_setaccessstrategy"></a>setAccessStrategy</h5>
<div class="paragraph">
<p>Tenga en cuenta que la estrategia de acceso a datos sin procesar que establezca aquí determina qué método de transformación llamará el marco. Implemente el método de transformación correspondiente a la estrategia de acceso a datos sin procesar. Por supuesto, también puede decidir dinámicamente qué estrategia establecer en función de los parámetros de atributo analizados por UDFParameters. Por lo tanto, también se permite implementar dos métodos de transformación en una UDF.</p>
</div>
<div class="paragraph">
<p>Las siguientes son las estrategias que puede establecer:
Definición de interfaz Descripción El método de transformación para llamar
RowByRowAccessStrategy Procesar datos sin procesar fila por fila. El marco llama al método de transformación una vez para cada fila de entrada de datos sin procesar. Cuando UDF tiene solo una secuencia de entrada, una fila de entrada es un punto de datos en la secuencia de entrada. Cuando UDF tiene varias secuencias de entrada, una fila de entrada es un registro de resultado de la consulta sin procesar (alineada por tiempo) en estas secuencias de entrada. (En una fila, puede haber una columna con un valor de nulo, pero no todas son nulas) void transform (Fila de fila, colector de PointCollector) arroja una excepción
SlidingTimeWindowAccessStrategy Procesa un lote de datos en un intervalo de tiempo fijo cada vez. Llamamos ventana al contenedor de un lote de datos. El marco llama al método de transformación una vez para cada ventana de entrada de datos sin procesar. Puede haber varias filas de datos en una ventana, y cada fila es un registro de resultado de la consulta sin procesar (alineada por tiempo) en estas secuencias de entrada. (En una fila, puede haber una columna con un valor de nulo, pero no todas son nulas) void transform (RowWindow rowWindow, colector PointCollector) arroja Exception
SlidingSizeWindowAccessStrategy Los datos sin procesar se procesan lote a lote, y cada lote contiene un número fijo de filas de datos sin procesar (excepto el último lote). Llamamos ventana al contenedor de un lote de datos. El marco llama al método de transformación una vez para cada ventana de entrada de datos sin procesar. Puede haber varias filas de datos en una ventana, y cada fila es un registro de resultado de la consulta sin procesar (alineada por tiempo) en estas secuencias de entrada. (En una fila, puede haber una columna con un valor de nulo, pero no todas son nulas) void transform (RowWindow rowWindow, colector PointCollector) arroja Exception</p>
</div>
<div class="paragraph">
<p>RowByRowAccessStrategy: La construcción de RowByRowAccessStrategy no requiere ningún parámetro.</p>
</div>
<div class="paragraph">
<p>SlidingTimeWindowAccessStrategy: SlidingTimeWindowAccessStrategy tiene muchos constructores, puede pasarles 3 tipos de parámetros:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Parámetro 1: la ventana de visualización en el eje del tiempo
Parámetro 2: intervalo de tiempo para dividir el eje de tiempo (debe ser positivo)
Parámetro 3: Paso deslizante de tiempo (no se requiere que sea mayor o igual al intervalo de tiempo, pero debe ser un número positivo)</pre>
</div>
</div>
<div class="paragraph">
<p>El primer tipo de parámetros son opcionales. Si no se proporcionan los parámetros, la hora de inicio de la ventana de visualización se establecerá igual que la marca de tiempo mínima del conjunto de resultados de la consulta, y la hora de finalización de la ventana de visualización se establecerá igual que la marca de tiempo máxima de la conjunto de resultados de la consulta.</p>
</div>
<div class="paragraph">
<p>El parámetro de paso deslizante también es opcional. Si el parámetro no se proporciona, el paso deslizante se establecerá en el mismo intervalo de tiempo para dividir el eje de tiempo.</p>
</div>
<div class="paragraph">
<p>La relación entre los tres tipos de parámetros se puede ver en la siguiente figura. Consulte el Javadoc para obtener más detalles.</p>
</div>
<div class="paragraph">
<p>Tenga en cuenta que el intervalo de tiempo real de algunas de las últimas ventanas de tiempo puede ser menor que el parámetro de intervalo de tiempo especificado. Además, puede haber casos en los que el número de filas de datos en algunas ventanas de tiempo sea 0. En estos casos, el marco también llamará al método de transformación para las ventanas vacías.</p>
</div>
<div class="paragraph">
<p>SlidingSizeWindowAccessStrategy: SlidingSizeWindowAccessStrategy tiene muchos constructores, puede pasarles 2 tipos de parámetros:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Parámetro 1: Tamaño de la ventana. Este parámetro especifica el número de filas de datos contenidas en una ventana de procesamiento de datos. Tenga en cuenta que el número de filas de datos en algunas de las últimas ventanas de tiempo puede ser menor que el número especificado de filas de datos.
Parámetro 2: Paso deslizante. Este parámetro significa el número de filas entre el primer punto de la siguiente ventana y el primer punto de la ventana actual. (No es necesario que este parámetro sea mayor o igual al tamaño de la ventana, pero debe ser un número positivo)</pre>
</div>
</div>
<div class="paragraph">
<p>El parámetro de paso deslizante es opcional. Si no se proporciona el parámetro, el paso de deslizamiento se establecerá en el mismo tamaño que el tamaño de la ventana.</p>
</div>
<div class="paragraph">
<p>Consulte el Javadoc para obtener más detalles.
#
setOutputDataType</p>
</div>
<div class="paragraph">
<p>Tenga en cuenta que el tipo de secuencia de salida que establezca aquí determina el tipo de datos que PointCollector realmente puede recibir en el método de transformación. La relación entre el tipo de datos de salida establecido en setOutputDataType y el tipo de salida de datos real que PointCollector puede recibir es la siguiente:
Tipo de datos de salida Establecido en setOutputDataType Tipo de datos que PointCollector puede recibir
INT32 int
INT64 largo
Flotador flotador
Doble doble
Booleano booleano
TEXTO java.lang.String y org.apache.iotdb.tsfile.utils.Binary</p>
</div>
<div class="paragraph">
<p>El tipo de serie de tiempo de salida de una UDTF se determina en tiempo de ejecución, lo que significa que una UDTF puede determinar dinámicamente el tipo de serie de tiempo de salida según el tipo de serie de tiempo de entrada. A continuación, se muestra un ejemplo sencillo:</p>
</div>
<div class="paragraph">
<p>void beforeStart (parámetros UDFParameters, configuraciones UDTFConfigurations) arroja Exception {
  // hacer algo
  // &#8230;&#8203;</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  configuraciones
    .setAccessStrategy (nuevo RowByRowAccessStrategy ())
    .setOutputDataType (parámetros.getDataType (0));
}</pre>
</div>
</div>
<div class="paragraph">
<p>#
void transform (fila fila, colector PointCollector) arroja una excepción</p>
</div>
<div class="paragraph">
<p>Debe implementar este método cuando especifica la estrategia de UDF para leer los datos originales como RowByRowAccessStrategy.</p>
</div>
<div class="paragraph">
<p>Este método procesa los datos sin procesar una fila a la vez. Los datos brutos se ingresan desde Row y se envían a PointCollector. Puede generar cualquier número de puntos de datos en una llamada al método de transformación. Cabe señalar que el tipo de puntos de datos de salida debe ser el mismo que estableció en el método beforeStart, y las marcas de tiempo de los puntos de datos de salida deben aumentar estrictamente de manera monótona.</p>
</div>
<div class="paragraph">
<p>El siguiente es un ejemplo de UDF completo que implementa la transformación void (fila de fila, colector de PointCollector) arroja el método de excepción. Es un sumador que recibe dos columnas de series de tiempo como entrada. Cuando dos puntos de datos en una fila no son nulos, esta UDF generará la suma algebraica de estos dos puntos de datos.</p>
</div>
<div class="paragraph">
<p>import org.apache.iotdb.db.query.udf.api.UDTF;
import org.apache.iotdb.db.query.udf.api.access.Row;
import org.apache.iotdb.db.query.udf.api.collector.PointCollector;
importar org.apache.iotdb.db.query.udf.api.customizer.config.UDTFConfigurations;
import org.apache.iotdb.db.query.udf.api.customizer.parameter.UDFParameters;
import org.apache.iotdb.db.query.udf.api.customizer.strategy.RowByRowAccessStrategy;
import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;</p>
</div>
<div class="paragraph">
<p>Adder de clase pública implementa UDTF {</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@Anular
public void beforeStart (parámetros UDFParameters, configuraciones UDTFConfigurations) {
  configuraciones
      .setOutputDataType (TSDataType.INT64)
      .setAccessStrategy (nuevo RowByRowAccessStrategy ());
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  @Anular
  public void transform (Fila fila, colector PointCollector) lanza Exception {
    if (fila.isNull (0) || fila.isNull (1)) {
      regresar;
    }
    collector.putLong (fila.getTime (), fila.getLong (0) + fila.getLong (1));
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>#
void transform (RowWindow rowWindow, colector PointCollector) arroja una excepción</p>
</div>
<div class="paragraph">
<p>Debe implementar este método cuando especifica la estrategia de UDF para leer los datos originales como SlidingTimeWindowAccessStrategy o SlidingSizeWindowAccessStrategy.</p>
</div>
<div class="paragraph">
<p>Este método procesa un lote de datos en un número fijo de filas o un intervalo de tiempo fijo cada vez, y llamamos ventana al contenedor que contiene este lote de datos. Los datos brutos se ingresan desde RowWindow y se envían a PointCollector. RowWindow puede ayudarlo a acceder a un lote de Row, proporciona un conjunto de interfaces para acceso aleatorio y acceso iterativo a este lote de Row. Puede generar cualquier número de puntos de datos en una llamada al método de transformación. Cabe señalar que el tipo de puntos de datos de salida debe ser el mismo que estableció en el método beforeStart, y las marcas de tiempo de los puntos de datos de salida deben aumentar estrictamente de forma monotónica.</p>
</div>
<div class="paragraph">
<p>A continuación se muestra un ejemplo de UDF completo que implementa la transformación void (RowWindow rowWindow, colector PointCollector) arroja el método Exception. Es un contador que recibe cualquier número de series de tiempo como entrada, y su función es contar y generar el número de filas de datos en cada ventana de tiempo dentro de un rango de tiempo especificado.</p>
</div>
<div class="paragraph">
<p>import java.io.IOException;
import org.apache.iotdb.db.query.udf.api.UDTF;
import org.apache.iotdb.db.query.udf.api.access.RowWindow;
import org.apache.iotdb.db.query.udf.api.collector.PointCollector;
importar org.apache.iotdb.db.query.udf.api.customizer.config.UDTFConfigurations;
import org.apache.iotdb.db.query.udf.api.customizer.parameter.UDFParameters;
import org.apache.iotdb.db.query.udf.api.customizer.strategy.SlidingTimeWindowAccessStrategy;
import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;</p>
</div>
<div class="paragraph">
<p>Contador de clase pública implementa UDTF {</p>
</div>
<div class="literalblock">
<div class="content">
<pre>@Anular
public void beforeStart (parámetros UDFParameters, configuraciones UDTFConfigurations) {
  configuraciones
      .setOutputDataType (TSDataType.INT32)
      .setAccessStrategy (nueva SlidingTimeWindowAccessStrategy (
          parameters.getLong ("time_interval"),
          parameters.getLong ("paso_deslizante"),
          parameters.getLong ("display_window_begin"),
          parameters.getLong ("display_window_end")));
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  @Anular
  transformación public void (RowWindow rowWindow, colector PointCollector) {
    if (rowWindow.windowSize ()! = 0) {
      collector.putInt (rowWindow.getRow (0) .getTime (), rowWindow.windowSize ());
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>#
void terminate (colector PointCollector) arroja una excepción</p>
</div>
<div class="paragraph">
<p>En algunos escenarios, una UDF necesita atravesar todos los datos originales para calcular los puntos de datos de salida finales. La interfaz de terminación proporciona soporte para esos escenarios.</p>
</div>
<div class="paragraph">
<p>Este método se llama después de que se ejecutan todas las llamadas de transformación y antes de que se ejecute el método beforeDestory. Puede implementar el método de transformación para realizar un procesamiento de datos puro (sin generar ningún punto de datos) e implementar el método de terminación para generar los resultados del procesamiento.</p>
</div>
<div class="paragraph">
<p>Los resultados del procesamiento deben ser generados por PointCollector. Puede generar cualquier número de puntos de datos en una llamada al método de terminación. Cabe señalar que el tipo de puntos de datos de salida debe ser el mismo que estableció en el método beforeStart, y las marcas de tiempo de los puntos de datos de salida deben aumentar estrictamente de manera monótona.</p>
</div>
<div class="paragraph">
<p>A continuación se muestra un ejemplo de UDF completo que implementa el método de excepción de lanzamiento de void terminate (colector PointCollector). Toma una serie de tiempo cuyo tipo de datos es INT32 como entrada y genera el punto de valor máximo de la serie.</p>
</div>
<div class="paragraph">
<p>import java.io.IOException;
import org.apache.iotdb.db.query.udf.api.UDTF;
import org.apache.iotdb.db.query.udf.api.access.Row;
import org.apache.iotdb.db.query.udf.api.collector.PointCollector;
importar org.apache.iotdb.db.query.udf.api.customizer.config.UDTFConfigurations;
import org.apache.iotdb.db.query.udf.api.customizer.parameter.UDFParameters;
import org.apache.iotdb.db.query.udf.api.customizer.strategy.RowByRowAccessStrategy;
import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;</p>
</div>
<div class="paragraph">
<p>La clase pública Max implementa UDTF {</p>
</div>
<div class="literalblock">
<div class="content">
<pre>privado mucho tiempo;
valor int privado;</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Anular
public void beforeStart (parámetros UDFParameters, configuraciones UDTFConfigurations) {
  configuraciones
      .setOutputDataType (TSDataType.INT32)
      .setAccessStrategy (nuevo RowByRowAccessStrategy ());
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>@Anular
transformación de vacío público (fila de fila, colector de PointCollector) {
  int candidatoValue = fila.getInt (0);
  if (tiempo == nulo || valor &lt;valor candidato) {
    tiempo = fila.getTime ();
    valor = candidatoValor;
  }
}</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  @Anular
  public void terminate (colector PointCollector) lanza IOException {
    if (tiempo! = nulo) {
      collector.putInt (tiempo, valor);
    }
  }
}</pre>
</div>
</div>
<div class="paragraph">
<p>#
void beforeDestroy ()</p>
</div>
<div class="paragraph">
<p>El método para terminar una UDF.</p>
</div>
<div class="paragraph">
<p>Este método es llamado por el framework. Para una instancia de UDF, beforeDestroy se llamará después de que se procese el último registro. En todo el ciclo de vida de la instancia, beforeDestroy solo se llamará una vez.
#
Ejemplo de proyecto Maven</p>
</div>
<div class="paragraph">
<p>Si usa Maven, puede crear su propio proyecto UDF consultando nuestro módulo de ejemplo udf. Puedes encontrar el proyecto aquí</p>
</div>
<div class="paragraph">
<p>(abre una nueva ventana).
#
Registro UDF</p>
</div>
<div class="paragraph">
<p>El proceso de registro de una UDF en IoTDB es el siguiente:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Implemente una clase UDF completa, asumiendo que el nombre de clase completo de esta clase es org.apache.iotdb.udf.ExampleUDTF.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Empaqueta tu proyecto en un JAR. Si usa Maven para administrar su proyecto, puede consultar el ejemplo de proyecto de Maven anterior.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Coloque el paquete JAR en el directorio iotdb-server-0.12.0-SNAPSHOT / ext / udf o en un subdirectorio de iotdb-server-0.12.0-SNAPSHOT / ext / udf.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Puede especificar la ruta raíz para que la UDF cargue el Jar modificando 'udf_root_dir' en el archivo de configuración.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Registre la UDF con la instrucción SQL, asumiendo que el nombre dado a la UDF es ejemplo.</pre>
</div>
</div>
<div class="paragraph">
<p>A continuación se muestra la sintaxis SQL de cómo registrar una UDF.</p>
</div>
<div class="paragraph">
<p>CREAR LA FUNCIÓN &lt;UDF-NAME&gt; COMO &lt;UDF-CLASS-FULL-PATHNAME&gt;</p>
</div>
<div class="paragraph">
<p>Aquí hay un ejemplo:</p>
</div>
<div class="paragraph">
<p>Ejemplo de CREATE FUNCTION COMO "org.apache.iotdb.udf.ExampleUDTF"</p>
</div>
<div class="paragraph">
<p>Dado que las instancias de UDF se cargan dinámicamente a través de la tecnología de reflexión, no es necesario reiniciar el servidor durante el proceso de registro de UDF.</p>
</div>
<div class="paragraph">
<p>Nota: Los nombres de las funciones UDF no distinguen entre mayúsculas y minúsculas.</p>
</div>
<div class="paragraph">
<p>Nota: asegúrese de que el nombre de función dado a la UDF sea diferente de todos los nombres de función incorporados. No se puede registrar una UDF con el mismo nombre que una función incorporada.</p>
</div>
<div class="paragraph">
<p>Nota: Recomendamos que no use clases que tengan el mismo nombre de clase pero una lógica de función diferente en diferentes paquetes JAR. Por ejemplo, en UDF (UDAF / UDTF): udf1, udf2, el paquete JAR de udf1 es udf1.jar y el paquete JAR de udf2 es udf2.jar. Suponga que ambos paquetes JAR contienen la clase org.apache.iotdb.udf.ExampleUDTF. Si usa dos UDF en la misma instrucción SQL al mismo tiempo, el sistema cargará cualquiera de ellos de forma aleatoria y puede causar inconsistencias en el comportamiento de ejecución de UDF.
#
Baja de UDF</p>
</div>
<div class="paragraph">
<p>A continuación, se muestra la sintaxis SQL de cómo cancelar el registro de una UDF.</p>
</div>
<div class="paragraph">
<p>FUNCIÓN DROP &lt;UDF-NAME&gt;</p>
</div>
<div class="paragraph">
<p>Aquí hay un ejemplo:</p>
</div>
<div class="paragraph">
<p>Ejemplo de FUNCIÓN DROP</p>
</div>
<div class="paragraph">
<p>#
Consultas UDF</p>
</div>
<div class="paragraph">
<p>El uso de UDF es similar al de las funciones de agregación integradas.
#
Soporte de sintaxis SQL básica</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Soporte SLIMIT / SOFFSET
Soporte LIMIT / OFFSET
Soporte NO ALINEADO
Soporte de consultas con filtros de tiempo
Soporte de consultas con filtros de valor</pre>
</div>
</div>
<div class="paragraph">
<p>#
Consultas con * en cláusulas SELECT</p>
</div>
<div class="paragraph">
<p>Suponga que hay 2 series de tiempo (root.sg.d1.s1 y root.sg.d1.s2) en el sistema.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SELECCIONAR ejemplo (*) de root.sg.d1</pre>
</div>
</div>
<div class="paragraph">
<p>Luego, el conjunto de resultados incluirá los resultados de example (root.sg.d1.s1) y example (root.sg.d1.s2).</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SELECT ejemplo (s1, *) de root.sg.d1</pre>
</div>
</div>
<div class="paragraph">
<p>Luego, el conjunto de resultados incluirá los resultados de ejemplo (root.sg.d1.s1, root.sg.d1.s1) y ejemplo (root.sg.d1.s1, root.sg.d1.s2).</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SELECT ejemplo (*, *) de root.sg.d1</pre>
</div>
</div>
<div class="paragraph">
<p>Luego, el conjunto de resultados incluirá los resultados de ejemplo (root.sg.d1.s1, root.sg.d1.s1), ejemplo (root.sg.d1.s2, root.sg.d1.s1), ejemplo (root .sg.d1.s1, root.sg.d1.s2) y ejemplo (root.sg.d1.s2, root.sg.d1.s2).
#
Consultas con atributos de valor-clave en parámetros UDF</p>
</div>
<div class="paragraph">
<p>Puede pasar cualquier número de parámetros de pares clave-valor a la UDF al construir una consulta de UDF. La clave y el valor del par clave-valor deben incluirse entre comillas simples o dobles. Tenga en cuenta que los parámetros del par clave-valor solo se pueden transferir después de que se hayan transmitido todas las series de tiempo. A continuación, se muestra un conjunto de ejemplos:</p>
</div>
<div class="paragraph">
<p>SELECT ejemplo (s1, "clave1" = "valor1", "clave2" = "valor2"), ejemplo (*, "clave3" = "valor3") FROM root.sg.d1;
SELECT ejemplo (s1, s2, "clave1" = "valor1", "clave2" = "valor2") FROM root.sg.d1;</p>
</div>
<div class="paragraph">
<p>#
Consultas híbridas</p>
</div>
<div class="paragraph">
<p>Actualmente, IoTDB admite consultas híbridas de consultas UDF y consultas de datos sin procesar, por ejemplo:</p>
</div>
<div class="paragraph">
<p>SELECCIONE s1, s2, ejemplo (s1, s2) DE root.sg.d1;
SELECT <strong>, ejemplo (</strong>) FROM root.sg.d1 NON ALIGN;</p>
</div>
<div class="paragraph">
<p>#
Mostrar todas las UDF registradas</p>
</div>
<div class="paragraph">
<p>MOSTRAR FUNCIONES</p>
</div>
<div class="paragraph">
<p>#
Gestión de permisos de usuario</p>
</div>
<div class="paragraph">
<p>Hay 3 tipos de permisos de usuario relacionados con UDF:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>CREATE_FUNCTION: solo los usuarios con este permiso pueden registrar UDF
DROP_FUNCTION: solo los usuarios con este permiso pueden cancelar el registro de UDF
READ_TIMESERIES: solo los usuarios con este permiso pueden usar UDF para consultas</pre>
</div>
</div>
<div class="paragraph">
<p>Para obtener más contenido relacionado con los permisos de usuario, consulte Estados de cuenta de administración.
#
Propiedades configurables</p>
</div>
<div class="paragraph">
<p>Al realizar consultas mediante una UDF, IoTDB puede indicar que no hay memoria suficiente. Puede resolver el problema configurando udf_initial_byte_array_length_for_memory_control, udf_memory_budget_in_mb y udf_reader_transformer_collector_memory_proportion en iotdb-engine.properties y reiniciando el servidor.
#
Contribuir UDF</p>
</div>
<div class="paragraph">
<p>Esta parte presenta principalmente cómo los usuarios externos pueden contribuir con sus propias UDF a la comunidad de IoTDB.
#
Prerrequisitos</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Las UDF deben ser universales.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>El "universal" mencionado aquí se refiere a: Las UDF se pueden utilizar ampliamente en algunos escenarios. En otras palabras, la función UDF debe tener valor de reutilización y puede ser utilizada directamente por otros usuarios de la comunidad.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Si no está seguro de si el UDF con el que desea contribuir es universal, puede enviar un correo electrónico a dev@iotdb.apache.org o crear un problema para iniciar una discusión.</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>La UDF con la que va a contribuir ha sido bien probada y puede ejecutarse normalmente en el entorno de producción.</pre>
</div>
</div>
<div class="paragraph">
<p>#
Que necesitas preparar</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Código fuente UDF
Casos de prueba
Instrucciones</pre>
</div>
</div>
<div class="paragraph">
<p>#
Código fuente UDF</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Cree la clase principal de UDF y las clases relacionadas en src / main / java / org / apache / iotdb / db / query / udf / builtin o en sus subcarpetas.
Registre su UDF en src / main / java / org / apache / iotdb / db / query / udf / builtin / BuiltinFunction.java.</pre>
</div>
</div>
<div class="paragraph">
<p>#
Casos de prueba</p>
</div>
<div class="paragraph">
<p>Como mínimo, debe escribir pruebas de integración para la UDF.</p>
</div>
<div class="paragraph">
<p>Puede agregar una clase de prueba en server / src / test / java / org / apache / iotdb / db / integration.
#
Instrucciones</p>
</div>
<div class="paragraph">
<p>Las instrucciones deben incluir: el nombre y la función de la UDF, los parámetros de atributo que deben proporcionarse cuando se ejecuta la UDF, los escenarios aplicables y los ejemplos de uso, etc.</p>
</div>
<div class="paragraph">
<p>Las instrucciones deben agregarse en docs / UserGuide / Operation Manual / DML Data Manipulation Language.md.
#
Envíe un PR</p>
</div>
<div class="paragraph">
<p>Cuando haya preparado el código fuente de UDF, los casos de prueba y las instrucciones, estará listo para enviar una solicitud de extracción (PR) en Github.
(abre una nueva ventana). Puede consultar nuestra guía de contribución de código para enviar un PR: Pull Request Guide</p>
</div>
<div class="paragraph">
<p>(abre una nueva ventana).
#
Bibliotecas UDF de implementación conocida</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Calidad IoTDB</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>(se abre en una ventana nueva), una biblioteca UDF sobre la calidad de los datos, incluida la elaboración de perfiles de datos, la evaluación de la calidad de los datos y la reparación de datos, etc.</pre>
</div>
</div>
<div class="paragraph">
<p>#
Preguntas y respuestas</p>
</div>
<div class="paragraph">
<p>P1: <strong> ¿Cómo modificar la UDF registrada? </strong></p>
</div>
<div class="paragraph">
<p>R1: Suponga que el nombre de la UDF es example y el nombre completo de la clase es org.apache.iotdb.udf.ExampleUDTF, que se introduce con example.jar.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Descargue la función registrada ejecutando el ejemplo DROP FUNCTION.
Elimine example.jar en iotdb-server-0.12.0-SNAPSHOT / ext / udf.
Modifique la lógica en org.apache.iotdb.udf.ExampleUDTF y vuelva a empaquetarla. El nombre del paquete JAR aún puede ser example.jar.
Cargue el nuevo paquete JAR en iotdb-server-0.12.0-SNAPSHOT / ext / udf.
Cargue la nueva UDF ejecutando CREATE FUNCTION example AS "org.apache.iotdb.udf.ExampleUDTF".</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>Esta página fue hecha usando la interfaz predeterminada de Antora.</p>
  <p>El código de esta interfaz está licenciado bajo los términos de la licencia MPL-2.0.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>

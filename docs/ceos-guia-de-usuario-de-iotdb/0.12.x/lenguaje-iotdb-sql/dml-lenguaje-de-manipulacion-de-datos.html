<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>DML (lenguaje de manipulación de datos) :: Guía de Usuario de IoTDB</title>
    <link rel="canonical" href="https://aumandaris.github.io/ceos-guia-de-usuario-de-iotdb/ceos-guia-de-usuario-de-iotdb/0.12.x/index.html/ceos-guia-de-usuario-de-iotdb/0.12.x/lenguaje-iotdb-sql/dml-lenguaje-de-manipulacion-de-datos.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://aumandaris.github.io/ceos-guia-de-usuario-de-iotdb/ceos-guia-de-usuario-de-iotdb/0.12.x/index.html">
        <img src="/ceos-guia-de-usuario-de-iotdb/ceos-guia-de-usuario-de-iotdb/0.12.x/_images/ceos-logo.png" width="40">
        <span>Guía de Usuario de IoTDB<span>     
      </a>
    </div>
    <div id="topbar-nav" class="navbar-menu">
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="ceos-guia-de-usuario-de-iotdb" data-version="0.12.x">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">Guía de Usuario de IoTDB</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Introducción a IoTDB</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduccion-a-iotdb/que-es-iotdb.html">Qué es IoTDB</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduccion-a-iotdb/arquitectura.html">Arquitectura</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="#introduccion-a-iotdb/escenario.adoc">Escenarios</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduccion-a-iotdb/caracteristicas.html">Características</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../introduccion-a-iotdb/publicacion.html">Publicación</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Inicio Rápido</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../inicio-rapido/inicio-rapido.html">Inicio Rápido</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../inicio-rapido/configuracion-de-ruta-de-almacenamiento.html">Configuración de Ruta de Almacenamiento</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../inicio-rapido/obtener-archivos-binarios-de-iotdb.html">Obtener Archivos Binarios de IoTDB</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Concepto de Datos</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepto-de-datos/modelo-de-datos-y-terminologia.html">Modelo de Datos y Terminología</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepto-de-datos/tipo-de-datos.html">Tipo de Datos</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepto-de-datos/codificacion.html">Codificación</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepto-de-datos/compresion.html">Compresión</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../concepto-de-datos/sdt.html">SDT</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Interfaz de Línea de Comandos</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../interfaz-de-linea-de-comandos/interfaz-de-linea-de-comandos.html">Interfaz de Línea de Comandos</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Gestión de la Administración</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../gestion-de-la-administracion/administracion.html">Administración</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Lenguaje IoTDB-SQL</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ddl-lenguaje-de-definicion-de-datos.html">DDL (Lenguaje de Definición de Datos)</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="dml-lenguaje-de-manipulacion-de-datos.html">DML (Lenguaje de Manipulación de Datos)</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="comando-de-mantenimiento.html">Comando de Mantenimiento</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">API (Interfaz de Programación de Aplicaciones)</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../api-interfaz-de-programacion-de-aplicaciones/jdbc.html">JDBC</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../api-interfaz-de-programacion-de-aplicaciones/api-nativa.html">API Nativa</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../api-interfaz-de-programacion-de-aplicaciones/otros-lenguajes.html">Otros Lenguajes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../api-interfaz-de-programacion-de-aplicaciones/api-tsfile.html">API TsFile</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">UDF (Función Definida por el Usuario)</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../udf-funcion-definida-por-el-usuario/udf-funcion-definida-por-el-usuario.html">Función Definida por el Usuario</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Protocolo de Servicio de Comunicación</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../protocolo-de-servicio-de-comunicacion/thrift.html">Thrift</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../protocolo-de-servicio-de-comunicacion/mqtt.html">MQTT</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Herramientas del Sistema</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../herramientas-del-sistema/cargar-herramienta-tsfile-externa.html">Cargar Archivo Ts Externo</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../herramientas-del-sistema/herramienta-de-seguimiento-del-rendimiento.html">Herramienta de Seguimiento del Rendimiento</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../herramientas-del-sistema/herramienta-csv.html">Herramienta CSV</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../herramientas-del-sistema/herramientas-de-monitoreo-y-registro.html">Herramientas de Monitorep y Registro</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../herramientas-del-sistema/herramienta-jmx.html">Herramienta JMX</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../herramientas-del-sistema/herramienta-mlogparser.html">Herramienta MLogParser</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../herramientas-del-sistema/herramienta-node.html">Herramienta Node</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../herramientas-del-sistema/herramienta-de-visualizacion-del-historial-de-consultas.html">Herramienta de Visualización del Historial de Consultas</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../herramientas-del-sistema/herramienta-de-marca-de-agua.html">Herramienta de Marca de Agua</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Colaboración de Edge y Cloud</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../colaboracion-de-edge-y-cloud/herramienta-de-sincronizacion.html">Herramienta de Sincronización</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Integración de Ecosistemas</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../integracion-de-ecosistemas/grafana.html">Grafana</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Preguntas Frecuentes</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../preguntas-frecuentes/preguntas-frecuentes.html">Preguntas Frecuentes</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Apéndice</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../apendice/manual-de-configuracion.html">Manual de Configuración</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../apendice/referencia-de-sql.html">Referencia SQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../apendice/codigos-de-estado.html">Códigos de Estado</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Guía de Usuario de IoTDB</span>
    <span class="version">0.12.x</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">Guía de Usuario de IoTDB</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">0.12.x</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">Guía de Usuario de IoTDB</a></li>
    <li>Lenguaje IoTDB-SQL</li>
    <li><a href="dml-lenguaje-de-manipulacion-de-datos.html">DML (Lenguaje de Manipulación de Datos)</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/Aumandaris/ceos-guia-de-usuario-de-iotdb/edit/master/modules/ROOT/pages/lenguaje-iotdb-sql/dml-lenguaje-de-manipulacion-de-datos.adoc">Editar esta página</a></div>
  </div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">DML (lenguaje de manipulación de datos)</h1>
<div class="sect1">
<h2 id="_insert"><a class="anchor" href="#_insert"></a>INSERT</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_insertar_datos_en_tiempo_real"><a class="anchor" href="#_insertar_datos_en_tiempo_real"></a>Insertar Datos en Tiempo Real</h3>
<div class="paragraph">
<p>IoTDB proporciona a los usuarios una variedad de formas de insertar datos en tiempo real, como ingresar directamente la [declaración INSERT SQL] en las [herramientas Cliente/Shell], o usar [Java JDBC] para realizar una ejecución única o por lotes de la [declaración INSERT SQL].</p>
</div>
<div class="paragraph">
<p>Esta sección presenta principalmente el uso de la [declaración INSERT SQL] para la importación de datos en tiempo real en el escenario.</p>
</div>
<div class="sect3">
<h4 id="_uso_de_declaraciones_insert"><a class="anchor" href="#_uso_de_declaraciones_insert"></a>Uso de Declaraciones INSERT</h4>
<div class="paragraph">
<p>La declaración de [declaración INSERT SQL] se utiliza para insertar datos en una o más series de tiempo especificadas creadas. Para cada punto de datos insertado, consta de una [marca de tiempo] y un valor de adquisición de sensor (consulte [Tipo de Datos]).</p>
</div>
<div class="paragraph">
<p>En el escenario de esta sección, tome dos series temporales <code>root.ln.wf02.wt02.status</code> y <code>root.ln.wf02.wt02.hardware</code> como ejemplo, y sus tipos de datos son BOOLEAN y TEXT, respectivamente.</p>
</div>
<div class="paragraph">
<p>El código de muestra para la inserción de datos de una sola columna es el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>IoTDB &gt; insert into root.ln.wf02.wt02(timestamp,status) values(1,true)
IoTDB &gt; insert into root.ln.wf02.wt02(timestamp,hardware) values(1, "v1")</code></pre>
</div>
</div>
<div class="paragraph">
<p>El código de ejemplo anterior inserta la marca de tiempo entera larga y el valor "true" en la serie temporal <code>root.ln.wf02.wt02.status</code> e inserta la marca de tiempo entera larga y el valor "v1" en la serie temporal <code>root.ln.wf02.wt02.hardware</code>. Cuando la ejecución es exitosa, se muestra el tiempo de costo para indicar que se completó la inserción de datos.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En IoTDB, los datos de tipo TEXT se pueden representar mediante comillas simples y dobles. La declaración de inserción anterior utiliza comillas dobles para los datos de tipo TEXTO. El siguiente ejemplo utilizará comillas simples para datos de tipo TEXT.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>La declaración INSERT también puede admitir la inserción de datos de varias columnas en el mismo momento. El código de muestra para insertar los valores de las dos series temporales en el mismo punto de tiempo '2' es el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>IoTDB &gt; insert into root.ln.wf02.wt02(timestamp, status, hardware) VALUES (2, false, 'v2')</code></pre>
</div>
</div>
<div class="paragraph">
<p>Después de insertar los datos, simplemente podemos consultar los datos insertados usando la declaración SELECT:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>IoTDB &gt; select * from root.ln.wf02 where time &lt; 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación. El resultado de la consulta muestra que las declaraciones de inserción de datos de una sola columna y de varias columnas se realizan correctamente.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+--------------------------+------------------------+
|                         Time|root.ln.wf02.wt02.hardware|root.ln.wf02.wt02.status|
+-----------------------------+--------------------------+------------------------+
|1970-01-01T08:00:00.001+08:00|                        v1|                    true|
|1970-01-01T08:00:00.002+08:00|                        v2|                   false|
+-----------------------------+--------------------------+------------------------+
Total line number = 2
It costs 0.170s</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_select"><a class="anchor" href="#_select"></a>SELECT</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_consulta_de_segmento_de_tiempo"><a class="anchor" href="#_consulta_de_segmento_de_tiempo"></a>Consulta de Segmento de Tiempo</h3>
<div class="paragraph">
<p>Este capítulo presenta principalmente los ejemplos relevantes de consultas de intervalos de tiempo utilizando declaraciones SELECT de IoTDB. La sintaxis SQL detallada y las especificaciones de uso se pueden encontrar en la [Documentación SQL]. También puede utilizar la interfaz estándar de [Java JDBC] para ejecutar consultas relacionadas.</p>
</div>
<div class="sect3">
<h4 id="_seleccionar_una_columna_de_datos_según_un_intervalo_de_tiempo"><a class="anchor" href="#_seleccionar_una_columna_de_datos_según_un_intervalo_de_tiempo"></a>Seleccionar una Columna de Datos Según un Intervalo de Tiempo</h4>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select temperature from root.ln.wf01.wt01 where time &lt; 2017-11-01T00:08:00.000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>El dispositivo seleccionado es en el grupo wf01 plant wt01 device; la serie de tiempo seleccionada es el sensor de temperatura (temperature). La declaración SQL requiere que se seleccionen todos los valores del sensor de temperatura antes del punto de tiempo "2017-11-01T00:08:00.000".</p>
</div>
<div class="paragraph">
<p>El resultado de la ejecución de esta declaración SQL es el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-----------------------------+
|                         Time|root.ln.wf01.wt01.temperature|
+-----------------------------+-----------------------------+
|2017-11-01T00:00:00.000+08:00|                        25.96|
|2017-11-01T00:01:00.000+08:00|                        24.36|
|2017-11-01T00:02:00.000+08:00|                        20.09|
|2017-11-01T00:03:00.000+08:00|                        20.18|
|2017-11-01T00:04:00.000+08:00|                        21.13|
|2017-11-01T00:05:00.000+08:00|                        22.72|
|2017-11-01T00:06:00.000+08:00|                        20.71|
|2017-11-01T00:07:00.000+08:00|                        21.45|
+-----------------------------+-----------------------------+
Total line number = 8
It costs 0.026s</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_seleccionar_varias_columnas_de_datos_según_un_intervalo_de_tiempo"><a class="anchor" href="#_seleccionar_varias_columnas_de_datos_según_un_intervalo_de_tiempo"></a>Seleccionar Varias Columnas de Datos Según un Intervalo de Tiempo</h4>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select status, temperature from root.ln.wf01.wt01 where time &gt; 2017-11-01T00:05:00.000 and time &lt; 2017-11-01T00:12:00.000;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>El dispositivo seleccionado es en el grupo wf01 plant wt01 device; la serie de tiempo seleccionada es "status" y "temperature". La declaración SQL requiere que se seleccionen los valores del sensor de temperatura y estado entre el punto de tiempo "2017-11-01T00:05:00.000" y "2017-11-01T00:12:00.000".</p>
</div>
<div class="paragraph">
<p>El resultado de la ejecución de esta declaración SQL es el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+------------------------+-----------------------------+
|                         Time|root.ln.wf01.wt01.status|root.ln.wf01.wt01.temperature|
+-----------------------------+------------------------+-----------------------------+
|2017-11-01T00:06:00.000+08:00|                   false|                        20.71|
|2017-11-01T00:07:00.000+08:00|                   false|                        21.45|
|2017-11-01T00:08:00.000+08:00|                   false|                        22.58|
|2017-11-01T00:09:00.000+08:00|                   false|                        20.98|
|2017-11-01T00:10:00.000+08:00|                    true|                        25.52|
|2017-11-01T00:11:00.000+08:00|                   false|                        22.91|
+-----------------------------+------------------------+-----------------------------+
Total line number = 6
It costs 0.018s</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_seleccionar_varias_columnas_de_datos_para_el_mismo_dispositivo_según_varios_intervalos_de_tiempo"><a class="anchor" href="#_seleccionar_varias_columnas_de_datos_para_el_mismo_dispositivo_según_varios_intervalos_de_tiempo"></a>Seleccionar Varias Columnas de Datos para el Mismo Dispositivo Según Varios Intervalos de Tiempo</h4>
<div class="paragraph">
<p>IoTDB admite la especificación de múltiples condiciones de intervalo de tiempo en una consulta. Los usuarios pueden combinar condiciones de intervalo de tiempo a voluntad según sus necesidades. Por ejemplo, la declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select status,temperature from root.ln.wf01.wt01 where (time &gt; 2017-11-01T00:05:00.000 and time &lt; 2017-11-01T00:12:00.000) or (time &gt;= 2017-11-01T16:35:00.000 and time &lt;= 2017-11-01T16:37:00.000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>El dispositivo seleccionado es en el grupo wf01 plant wt01 device; la serie de tiempo seleccionada es "status" y "temperature"; la declaración especifica dos intervalos de tiempo diferentes, a saber, "2017-11-01T00:05:00.000 to 2017-11-01T00:12:00.000" y "2017-11-01T16:35:00.000 to 2017-11-01T16:37:00.000". La declaración SQL requiere que se seleccionen los valores de las series temporales seleccionadas que satisfacen cualquier intervalo de tiempo.</p>
</div>
<div class="paragraph">
<p>El resultado de la ejecución de esta declaración SQL es el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+------------------------+-----------------------------+
|                         Time|root.ln.wf01.wt01.status|root.ln.wf01.wt01.temperature|
+-----------------------------+------------------------+-----------------------------+
|2017-11-01T00:06:00.000+08:00|                   false|                        20.71|
|2017-11-01T00:07:00.000+08:00|                   false|                        21.45|
|2017-11-01T00:08:00.000+08:00|                   false|                        22.58|
|2017-11-01T00:09:00.000+08:00|                   false|                        20.98|
|2017-11-01T00:10:00.000+08:00|                    true|                        25.52|
|2017-11-01T00:11:00.000+08:00|                   false|                        22.91|
|2017-11-01T16:35:00.000+08:00|                    true|                        23.44|
|2017-11-01T16:36:00.000+08:00|                   false|                        21.98|
|2017-11-01T16:37:00.000+08:00|                   false|                        21.93|
+-----------------------------+------------------------+-----------------------------+
Total line number = 9
It costs 0.018s</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_elegir_varias_columnas_de_datos_para_diferentes_dispositivos_según_múltiples_intervalos_de_tiempo"><a class="anchor" href="#_elegir_varias_columnas_de_datos_para_diferentes_dispositivos_según_múltiples_intervalos_de_tiempo"></a>Elegir Varias Columnas de Datos para Diferentes Dispositivos Según Múltiples Intervalos de Tiempo</h4>
<div class="paragraph">
<p>El sistema admite la selección de datos en cualquier columna de una consulta, es decir, las columnas seleccionadas pueden provenir de diferentes dispositivos. Por ejemplo, la declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select wf01.wt01.status,wf02.wt02.hardware from root.ln where (time &gt; 2017-11-01T00:05:00.000 and time &lt; 2017-11-01T00:12:00.000) or (time &gt;= 2017-11-01T16:35:00.000 and time &lt;= 2017-11-01T16:37:00.000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>Las series de tiempo seleccionadas son "el estado de la fuente de alimentación del dispositivo ln group wf01 plant wt01" y "la versión de hardware del dispositivo ln group wf02 plant wt02"; la declaración especifica dos intervalos de tiempo diferentes, a saber, "2017-11-01T00:05:00.000 to 2017-11-01T00:12:00.000" y "2017-11-01T16:35:00.000 to 2017-11-01T16:37:00.000". La declaración SQL requiere que se seleccionen los valores de las series temporales seleccionadas que satisfacen cualquier intervalo de tiempo.</p>
</div>
<div class="paragraph">
<p>El resultado de la ejecución de esta declaración SQL es el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+------------------------+--------------------------+
|                         Time|root.ln.wf01.wt01.status|root.ln.wf02.wt02.hardware|
+-----------------------------+------------------------+--------------------------+
|2017-11-01T00:06:00.000+08:00|                   false|                        v1|
|2017-11-01T00:07:00.000+08:00|                   false|                        v1|
|2017-11-01T00:08:00.000+08:00|                   false|                        v1|
|2017-11-01T00:09:00.000+08:00|                   false|                        v1|
|2017-11-01T00:10:00.000+08:00|                    true|                        v2|
|2017-11-01T00:11:00.000+08:00|                   false|                        v1|
|2017-11-01T16:35:00.000+08:00|                    true|                        v2|
|2017-11-01T16:36:00.000+08:00|                   false|                        v1|
|2017-11-01T16:37:00.000+08:00|                   false|                        v1|
+-----------------------------+------------------------+--------------------------+
Total line number = 9
It costs 0.014s</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ordenar_por_hora_de_consulta"><a class="anchor" href="#_ordenar_por_hora_de_consulta"></a>Ordenar por Hora de Consulta</h4>
<div class="paragraph">
<p>IoTDB admite la declaración 'order by time' desde 0.11, se usa para mostrar los resultados en orden descendente por tiempo. Por ejemplo, la declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select * from root.ln where time &gt; 1 order by time desc limit 10;</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado de la ejecución de esta declaración SQL es el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+--------------------------+------------------------+-----------------------------+------------------------+
|                         Time|root.ln.wf02.wt02.hardware|root.ln.wf02.wt02.status|root.ln.wf01.wt01.temperature|root.ln.wf01.wt01.status|
+-----------------------------+--------------------------+------------------------+-----------------------------+------------------------+
|2017-11-07T23:59:00.000+08:00|                        v1|                   false|                        21.07|                   false|
|2017-11-07T23:58:00.000+08:00|                        v1|                   false|                        22.93|                   false|
|2017-11-07T23:57:00.000+08:00|                        v2|                    true|                        24.39|                    true|
|2017-11-07T23:56:00.000+08:00|                        v2|                    true|                        24.44|                    true|
|2017-11-07T23:55:00.000+08:00|                        v2|                    true|                         25.9|                    true|
|2017-11-07T23:54:00.000+08:00|                        v1|                   false|                        22.52|                   false|
|2017-11-07T23:53:00.000+08:00|                        v2|                    true|                        24.58|                    true|
|2017-11-07T23:52:00.000+08:00|                        v1|                   false|                        20.18|                   false|
|2017-11-07T23:51:00.000+08:00|                        v1|                   false|                        22.24|                   false|
|2017-11-07T23:50:00.000+08:00|                        v2|                    true|                         23.7|                    true|
+-----------------------------+--------------------------+------------------------+-----------------------------+------------------------+
Total line number = 10
It costs 0.016s</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_funciones_de_generación_de_series_temporales"><a class="anchor" href="#_funciones_de_generación_de_series_temporales"></a>Funciones de Generación de Series Temporales</h4>
<div class="paragraph">
<p>La función de generación de series de tiempo toma varias series de tiempo como entrada y genera una serie de tiempo. A diferencia de la función de agregación, el conjunto de resultados de la función de generación de series de tiempo tiene una columna de marca de tiempo.</p>
</div>
<div class="paragraph">
<p>Todas las funciones de generación de series de tiempo pueden aceptar * como entrada.</p>
</div>
<div class="paragraph">
<p>IoTDB admite consultas híbridas de series de tiempo que generan consultas de funciones y consultas de datos sin procesar.</p>
</div>
<div class="sect4">
<h5 id="_funciones_matemáticas"><a class="anchor" href="#_funciones_matemáticas"></a>Funciones Matemáticas</h5>
<div class="paragraph">
<p>Actualmente, IoTDB admite las siguientes funciones matemáticas. El comportamiento de estas funciones matemáticas es coherente con el comportamiento de estas funciones en la biblioteca estándar Java Math.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nombre de la Función</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipos de Datos de Series de Entrada Permitidos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipos de Datos de Series de Salida</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Implementación Correspondiente en la Biblioteca Estándar de Java</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SIN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#sin(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#cos(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#tan(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ASIN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#asin(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ACOS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#acos(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ATAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#atan(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEGREES</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#toDegrees(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RADIANS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#toRadians(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ABS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Igual que la serie de entrada</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#abs(int) / Math#abs(long) /Math#abs(float) /Math#abs(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SIGN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#signum(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CEIL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#ceil(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FLOOR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#floor(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ROUND</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#rint(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#exp(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#log(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOG10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#log10(double)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SQRT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Math#sqrt(double)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select s1, sin(s1), cos(s1), tan(s1) from root.sg1.d1 limit 5 offset 1000;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------+-------------------+--------------------+-------------------+
|                         Time|     root.sg1.d1.s1|sin(root.sg1.d1.s1)| cos(root.sg1.d1.s1)|tan(root.sg1.d1.s1)|
+-----------------------------+-------------------+-------------------+--------------------+-------------------+
|2020-12-10T17:11:49.037+08:00|7360723084922759782| 0.8133527237573284|  0.5817708713544664| 1.3980636773094157|
|2020-12-10T17:11:49.038+08:00|4377791063319964531|-0.8938962705202537|  0.4482738644511651| -1.994085181866842|
|2020-12-10T17:11:49.039+08:00|7972485567734642915| 0.9627757585308978|-0.27030138509681073|-3.5618602479083545|
|2020-12-10T17:11:49.040+08:00|2508858212791964081|-0.6073417341629443| -0.7944406950452296| 0.7644897069734913|
|2020-12-10T17:11:49.041+08:00|2817297431185141819|-0.8419358900502509| -0.5395775727782725| 1.5603611649667768|
+-----------------------------+-------------------+-------------------+--------------------+-------------------+
Total line number = 5
It costs 0.008s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_funciones_de_procesamiento_de_cadenas"><a class="anchor" href="#_funciones_de_procesamiento_de_cadenas"></a>Funciones de Procesamiento de Cadenas</h5>
<div class="paragraph">
<p>Actualmente, IoTDB admite las siguientes funciones de procesamiento de cadenas:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nombre de la Función</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipos de Datos de las Series de Entrada Permitidos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Atributos Requeridos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipos de Datos de las Series de Salida</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Descripción</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">STRING_CONTAINS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TEXT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s</code>: la secuencia a buscar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determinar si <code>s</code> está en la cadena</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">STRING_MATCHES</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TEXT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>regex</code>: la expresión regular con la que debe coincidir la cadena</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOOLEAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Determinar si la cadena puede coincidir con <code>regex</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select s1, string_contains(s1, "s"="warn"), string_matches(s1, "regex"="[^\\s]+37229") from root.sg1.d4;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+--------------+-------------------------------------------+------------------------------------------------------+
|                         Time|root.sg1.d4.s1|string_contains(root.sg1.d4.s1, "s"="warn")|string_matches(root.sg1.d4.s1, "regex"="[^\\s]+37229")|
+-----------------------------+--------------+-------------------------------------------+------------------------------------------------------+
|1970-01-01T08:00:00.001+08:00|    warn:-8721|                                       true|                                                 false|
|1970-01-01T08:00:00.002+08:00|  error:-37229|                                      false|                                                  true|
|1970-01-01T08:00:00.003+08:00|     warn:1731|                                       true|                                                 false|
+-----------------------------+--------------+-------------------------------------------+------------------------------------------------------+
Total line number = 3
It costs 0.007s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_funciones_de_selector"><a class="anchor" href="#_funciones_de_selector"></a>Funciones de Selector</h5>
<div class="paragraph">
<p>Actualmente, IoTDB admite las siguientes funciones de selector:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nombre de la Función</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipos de Datos de las Series de Entrada Permitidos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Atributos Requeridos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipos de Datos de las Series de Salida</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Descripción</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TOP_K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE / TEXT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>k</code>: el número máximo de puntos de datos seleccionados, debe ser mayor que 0 y menor o igual que 1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">El mismo tipo que la serie de entrada</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Devuelve <code>k</code> puntos de datos con los valores más grandes en una serie de tiempo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BOTTOM_K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE / TEXT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>k</code>: el número máximo de puntos de datos seleccionados, debe ser mayor que 0 y menor o igual que 1000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mismo tipo que la serie de entrada</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Devuelve <code>k</code> puntos de datos con los valores más pequeños en una serie de tiempo</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select s1, top_k(s1, "k"="2"), bottom_k(s1, "k"="2") from root.sg1.d2 where time &gt; 2020-12-10T20:36:15.530+08:00;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+--------------------+------------------------------+---------------------------------+
|                         Time|      root.sg1.d2.s1|top_k(root.sg1.d2.s1, "k"="2")|bottom_k(root.sg1.d2.s1, "k"="2")|
+-----------------------------+--------------------+------------------------------+---------------------------------+
|2020-12-10T20:36:15.531+08:00| 1531604122307244742|           1531604122307244742|                             null|
|2020-12-10T20:36:15.532+08:00|-7426070874923281101|                          null|                             null|
|2020-12-10T20:36:15.533+08:00|-7162825364312197604|          -7162825364312197604|                             null|
|2020-12-10T20:36:15.534+08:00|-8581625725655917595|                          null|             -8581625725655917595|
|2020-12-10T20:36:15.535+08:00|-7667364751255535391|                          null|             -7667364751255535391|
+-----------------------------+--------------------+------------------------------+---------------------------------+
Total line number = 5
It costs 0.006s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_funciones_de_cálculo_de_tendencia_de_variación"><a class="anchor" href="#_funciones_de_cálculo_de_tendencia_de_variación"></a>Funciones de Cálculo de Tendencia de Variación</h5>
<div class="paragraph">
<p>Actualmente, IoTDB admite las siguientes funciones de cálculo de tendencias de variación:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nombre de la Función</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipos de Datos de las Series de Entrada Permitidos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Atributos Requeridos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipos de Datos de las Series de Salida</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Descripción</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIME_DIFFERENCE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE / BOOLEAN / TEXT</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calcula la diferencia entre la marca de tiempo de un punto de datos y la marca de tiempo del punto de datos anterior. No hay una salida correspondiente para el primer punto de datos.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DIFFERENCE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mismo tipo que la serie de entrada</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calcula la diferencia entre el valor de un punto de datos y el valor del punto de datos anterior. No hay una salida correspondiente para el primer punto de datos.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NON_NEGATIVE_DIFFERENCE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mismo tipo que la serie de entrada</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calcula el valor absoluto de la diferencia entre el valor de un punto de datos y el valor del punto de datos anterior. No hay una salida correspondiente para el primer punto de datos.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DERIVATIVE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calcula la tasa de cambio de un punto de datos en comparación con el punto de datos anterior, el resultado es igual a DIFFERENCE/TIME_DIFFERENCE. No hay una salida correspondiente para el primer punto de datos.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NON_NEGATIVE_DERIVATIVE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">INT32 / INT64 / FLOAT / DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOUBLE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calcula el valor absoluto de la tasa de cambio de un punto de datos en comparación con el punto de datos anterior, el resultado es igual a NON_NEGATIVE_DIFFERENCE/TIME_DIFFERENCE. No hay una salida correspondiente para el primer punto de datos.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Calcula el valor absoluto de la tasa de cambio de un punto de datos en comparación con el punto de datos anterior, el resultado es igual a NON_NEGATIVE_DIFFERENCE/TIME_DIFFERENCE. No hay una salida correspondiente para el primer punto de datos.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------+-------------------------------+--------------------------+---------------------------------------+--------------------------+---------------------------------------+
|                         Time|     root.sg1.d1.s1|time_difference(root.sg1.d1.s1)|difference(root.sg1.d1.s1)|non_negative_difference(root.sg1.d1.s1)|derivative(root.sg1.d1.s1)|non_negative_derivative(root.sg1.d1.s1)|
+-----------------------------+-------------------+-------------------------------+--------------------------+---------------------------------------+--------------------------+---------------------------------------+
|2020-12-10T17:11:49.037+08:00|7360723084922759782|                              1|      -8431715764844238876|                    8431715764844238876|    -8.4317157648442388E18|                  8.4317157648442388E18|
|2020-12-10T17:11:49.038+08:00|4377791063319964531|                              1|      -2982932021602795251|                    2982932021602795251|     -2.982932021602795E18|                   2.982932021602795E18|
|2020-12-10T17:11:49.039+08:00|7972485567734642915|                              1|       3594694504414678384|                    3594694504414678384|     3.5946945044146785E18|                  3.5946945044146785E18|
|2020-12-10T17:11:49.040+08:00|2508858212791964081|                              1|      -5463627354942678834|                    5463627354942678834|     -5.463627354942679E18|                   5.463627354942679E18|
|2020-12-10T17:11:49.041+08:00|2817297431185141819|                              1|        308439218393177738|                     308439218393177738|     3.0843921839317773E17|                  3.0843921839317773E17|
+-----------------------------+-------------------+-------------------------------+--------------------------+---------------------------------------+--------------------------+---------------------------------------+
Total line number = 5
It costs 0.014s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_funciones_de_generación_de_series_temporales_definidas_por_el_usuario"><a class="anchor" href="#_funciones_de_generación_de_series_temporales_definidas_por_el_usuario"></a>Funciones de Generación de Series Temporales Definidas por el Usuario</h5>
<div class="paragraph">
<p>Consulte [UDF (Función Definida por el Usuario)].</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_consulta_agregada"><a class="anchor" href="#_consulta_agregada"></a>Consulta Agregada</h4>
<div class="paragraph">
<p>Esta sección presenta principalmente los ejemplos relacionados de consulta agregada.</p>
</div>
<div class="sect4">
<h5 id="_contar_puntos"><a class="anchor" href="#_contar_puntos"></a>Contar Puntos</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(status) from root.ln.wf01.wt01;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-------------------------------+
|count(root.ln.wf01.wt01.status)|
+-------------------------------+
|                          10080|
+-------------------------------+
Total line number = 1
It costs 0.016s</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="_agregación_por_nivel"><a class="anchor" href="#_agregación_por_nivel"></a>Agregación por Nivel</h6>
<div class="paragraph">
<p>La <strong>declaración de agregación por nivel</strong> se utiliza para agregar en un nivel jerárquico específico de la ruta de la serie temporal. Para todas las rutas de series temporales, por convención, "level=0" representa el nivel raíz. Es decir, para contar los puntos de cualquier medición en "root.ln", el nivel debe establecerse en 1.</p>
</div>
<div class="paragraph">
<p>Por ejemplo, hay varias series en "root.ln.wf01", como "root.ln.wf01.wt01.status", "root.ln.wf01.wt02.status", "root.ln.wf01.wt03.status". Para contar el número de puntos de "status" de todas estas series, utilice la consulta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(status) from root.ln.wf01.* group by level=2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+----------------------------+
|COUNT(root.ln.wf01.*.status)|
+----------------------------+
|                       10080|
+----------------------------+
Total line number = 1
It costs 0.003s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Supongamos que agregamos otras dos series temporales, "root.ln.wf01.wt01.temperature" y "root.ln.wf02.wt01.temperature". Para consultar el recuento y la suma de "temperature" en la ruta "root.ln..", agregando en el level=2, utilice la siguiente declaración:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(temperature), sum(temperature) from root.ln.*.* group by level=2</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+---------------------------------+---------------------------------+-------------------------------+-------------------------------+
|count(root.ln.wf02.*.temperature)|count(root.ln.wf01.*.temperature)|sum(root.ln.wf02.*.temperature)|sum(root.ln.wf01.*.temperature)|
+---------------------------------+---------------------------------+-------------------------------+-------------------------------+
|                                8|                                4|                          228.0|              91.83000183105469|
+---------------------------------+---------------------------------+-------------------------------+-------------------------------+
Total line number = 1
It costs 0.013s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para consultar el recuento y la suma de la ruta "root.ln.<strong>.</strong>.temperature" agregando en el nivel "root.ln", simplemente establezca level=1</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(temperature), sum(temperature) from root.ln.*.* group by level=1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+------------------------------+----------------------------+
|count(root.ln.*.*.temperature)|sum(root.ln.*.*.temperature)|
+------------------------------+----------------------------+
|                            12|           319.8300018310547|
+------------------------------+----------------------------+
Total line number = 1
It costs 0.013s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Todas las funciones de agregación admitidas son: count, sum, avg, last_value, first_value, min_time, max_time, min_value, max_value. Cuando utilice cuatro agregaciones: sum, avg, min_value y max_value, asegúrese de que todas las series agregadas tengan exactamente el mismo tipo de datos. De lo contrario, generará un error de sintaxis.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_consulta_agregada_de_frecuencia_descendente"><a class="anchor" href="#_consulta_agregada_de_frecuencia_descendente"></a>Consulta Agregada de Frecuencia Descendente</h4>
<div class="paragraph">
<p>Esta sección presenta principalmente los ejemplos relacionados de consultas de agregación de frecuencia descendente, utilizando la [cláusula GROUP BY], que se usa para dividir el conjunto de resultados de acuerdo con las condiciones de particionamiento dadas por el usuario y agregar el conjunto de resultados particionado. IoTDB admite el particionamiento de conjuntos de resultados de acuerdo con el intervalo de tiempo y el paso deslizante personalizado que no debe ser más pequeño que el intervalo de tiempo y por defecto es igual al intervalo de tiempo si no se establece. Y, de forma predeterminada, los resultados se ordenan por tiempo en orden ascendente. También puede utilizar la interfaz estándar de [Java JDBC] para ejecutar consultas relacionadas.</p>
</div>
<div class="paragraph">
<p>La declaración GROUP BY proporciona a los usuarios tres tipos de parámetros especificados:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Parámetro 1: la ventana de visualización en el eje del tiempo</p>
</li>
<li>
<p>Parámetro 2: intervalo de tiempo para dividir el eje de tiempo (debe ser positivo)</p>
</li>
<li>
<p>Parámetro 3: paso deslizante de tiempo (opcional y no debe ser menor que el intervalo de tiempo y el valor predeterminado es igual al intervalo de tiempo si no se establece)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Los significados reales de los tres tipos de parámetros se muestran en la Figura 5.2 a continuación. Entre ellos, el parámetro 3 es opcional. Hay tres ejemplos típicos de agregación de reducción de frecuencia: parámetro 3 no especificado, parámetro 3 especificado y condiciones de filtrado de valores especificadas.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../_images/imagen-11.png" alt="imagen 11">
</div>
<div class="title">Figure 1. Los significados reales de los tres tipos de parámetros</div>
</div>
<div class="sect4">
<h5 id="_consulta_agregada_de_frecuencia_descendente_sin_especificar_la_longitud_del_paso_deslizante"><a class="anchor" href="#_consulta_agregada_de_frecuencia_descendente_sin_especificar_la_longitud_del_paso_deslizante"></a>Consulta Agregada de Frecuencia Descendente sin Especificar la Longitud del Paso Deslizante</h5>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(status), max_value(temperature) from root.ln.wf01.wt01 group by ([2017-11-01T00:00:00, 2017-11-07T23:00:00),1d);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>Dado que la longitud del paso de deslizamiento no está especificada, la declaración GROUP BY por defecto establece el paso de deslizamiento igual que el intervalo de tiempo que es <code>1d</code>.</p>
</div>
<div class="paragraph">
<p>El primer parámetro de la declaración GROUP BY anterior es el parámetro de la ventana de visualización, que determina que el rango de visualización final es [2017-11-01T00:00:00, 2017-11-07T23:00:00).</p>
</div>
<div class="paragraph">
<p>El segundo parámetro de la declaración GROUP BY anterior es el intervalo de tiempo para dividir el eje de tiempo. Tomando este parámetro (1d) como intervalo de tiempo y startTime de la ventana de visualización como origen de división, el eje de tiempo se divide en varios intervalos continuos, que son  [0,1d), [1d, 2d), [2d, 3d), etc.</p>
</div>
<div class="paragraph">
<p>Luego, el sistema usará la condición de filtrado de tiempo y valor en la cláusula WHERE y el primer parámetro de la declaración GROUP BY como condición de filtrado de datos para obtener los datos que satisfacen la condición de filtrado (que en este caso son los datos en el rango de [2017-11-01T00:00:00, 2017-11-07 T23:00:00]), y mapee estos datos al eje de tiempo previamente segmentado (en este caso, hay datos mapeados en cada período de 1 día desde 2017-11-01T00:00:00 a 2017-11-07T23:00:00:00).</p>
</div>
<div class="paragraph">
<p>Dado que hay datos para cada período de tiempo en el rango de resultados que se mostrarán, el resultado de la ejecución de la declaración SQL se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------------------+----------------------------------------+
|                         Time|count(root.ln.wf01.wt01.status)|max_value(root.ln.wf01.wt01.temperature)|
+-----------------------------+-------------------------------+----------------------------------------+
|2017-11-01T00:00:00.000+08:00|                           1440|                                    26.0|
|2017-11-02T00:00:00.000+08:00|                           1440|                                    26.0|
|2017-11-03T00:00:00.000+08:00|                           1440|                                   25.99|
|2017-11-04T00:00:00.000+08:00|                           1440|                                    26.0|
|2017-11-05T00:00:00.000+08:00|                           1440|                                    26.0|
|2017-11-06T00:00:00.000+08:00|                           1440|                                   25.99|
|2017-11-07T00:00:00.000+08:00|                           1380|                                    26.0|
+-----------------------------+-------------------------------+----------------------------------------+
Total line number = 7
It costs 0.024s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_consulta_agregada_de_frecuencia_descendente_que_especifica_la_longitud_del_paso_deslizante"><a class="anchor" href="#_consulta_agregada_de_frecuencia_descendente_que_especifica_la_longitud_del_paso_deslizante"></a>Consulta Agregada de Frecuencia Descendente que Especifica la Longitud del Paso Deslizante</h5>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(status), max_value(temperature) from root.ln.wf01.wt01 group by ([2017-11-01 00:00:00, 2017-11-07 23:00:00), 3h, 1d);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>Dado que el usuario especifica el parámetro de paso deslizante como 1d, la declaración GROUP BY moverá el intervalo de tiempo <code>1 day</code> en lugar de <code>3 hours</code> como predeterminado.</p>
</div>
<div class="paragraph">
<p>Eso significa que queremos recuperar todos los datos de 00:00:00 a 02:59:59 todos los días desde 2017-11-01 hasta 2017-11-07.</p>
</div>
<div class="paragraph">
<p>El primer parámetro de la declaración GROUP BY anterior es el parámetro de la ventana de visualización, que determina que el rango de visualización final es [2017-11-01T00:00:00, 2017-11-07T23:00:00).</p>
</div>
<div class="paragraph">
<p>El segundo parámetro de la declaración GROUP BY anterior es el intervalo de tiempo para dividir el eje de tiempo. Tomando este parámetro (3h) como intervalo de tiempo y el startTime de la ventana de visualización como origen de división, el eje de tiempo se divide en varios intervalos continuos, que son [2017-11-01T00:00:00, 2017-11-01T03:00:00), [2017-11-02T00:00:00, 2017-11-02T03:00:00), [2017-11-03T00:00:00, 2017-11-03T03:00:00), etc.</p>
</div>
<div class="paragraph">
<p>El tercer parámetro de la declaración GROUP BY anterior es el paso deslizante para cada intervalo de tiempo que se mueve.</p>
</div>
<div class="paragraph">
<p>Luego, el sistema usará la condición de filtrado de tiempo y valor en la cláusula WHERE y el primer parámetro de la declaración GROUP BY como condición de filtrado de datos para obtener los datos que satisfacen la condición de filtrado (que en este caso son los datos en el rango de [2017-11-01T00:00:00, 2017-11-07T23:00:00]), y mapee estos datos al eje de tiempo previamente segmentado (en este caso, hay datos mapeados en cada período de 3 horas para cada día desde 2017-11-01T00:00:00 a 2017-11-07T23:00:00:00).</p>
</div>
<div class="paragraph">
<p>Dado que hay datos para cada período de tiempo en el rango de resultados que se mostrarán, el resultado de la ejecución de la declaración SQL se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------------------+----------------------------------------+
|                         Time|count(root.ln.wf01.wt01.status)|max_value(root.ln.wf01.wt01.temperature)|
+-----------------------------+-------------------------------+----------------------------------------+
|2017-11-01T00:00:00.000+08:00|                            180|                                   25.98|
|2017-11-02T00:00:00.000+08:00|                            180|                                   25.98|
|2017-11-03T00:00:00.000+08:00|                            180|                                   25.96|
|2017-11-04T00:00:00.000+08:00|                            180|                                   25.96|
|2017-11-05T00:00:00.000+08:00|                            180|                                    26.0|
|2017-11-06T00:00:00.000+08:00|                            180|                                   25.85|
|2017-11-07T00:00:00.000+08:00|                            180|                                   25.99|
+-----------------------------+-------------------------------+----------------------------------------+
Total line number = 7
It costs 0.006s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_consulta_agregada_de_frecuencia_descendente_por_mes_natural"><a class="anchor" href="#_consulta_agregada_de_frecuencia_descendente_por_mes_natural"></a>Consulta Agregada de Frecuencia Descendente por Mes Natural</h5>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(status) from root.ln.wf01.wt01 group by([2017-11-01T00:00:00, 2019-11-07T23:00:00), 1mo, 2mo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>Dado que el usuario especifica el parámetro de paso deslizante como <code>2mo</code>, la declaración GROUP BY moverá el intervalo de tiempo a 2 <code>months</code> en lugar de <code>1 month</code> como predeterminado.</p>
</div>
<div class="paragraph">
<p>El primer parámetro de la declaración GROUP BY anterior es el parámetro de la ventana de visualización, que determina que el rango de visualización final es [2017-11-01T00:00:00, 2019-11-07T23:00:00).</p>
</div>
<div class="paragraph">
<p>La hora de inicio es 2017-11-01T00:00:00. El paso deslizante aumentará mensualmente en función de la fecha de inicio, y el primer día del mes se utilizará como hora de inicio del intervalo de tiempo.</p>
</div>
<div class="paragraph">
<p>El segundo parámetro de la declaración GROUP BY anterior es el intervalo de tiempo para dividir el eje de tiempo. Tomando este parámetro (1mos) como intervalo de tiempo y el startTime de la ventana de visualización como origen de división, el eje de tiempo se divide en varios intervalos continuos, que son [2017-11-01T00:00:00, 2017-12-01T00:00:00), [2018-02-01T00:00:00, 2018-03-01T00:00:00), [2018-05-03T00:00:00, 2018-06-01T00:00:00)), etc.</p>
</div>
<div class="paragraph">
<p>El tercer parámetro de la declaración GROUP BY anterior es el paso deslizante para cada intervalo de tiempo que se mueve.</p>
</div>
<div class="paragraph">
<p>Luego, el sistema usará la condición de filtrado de tiempo y valor en la cláusula WHERE y el primer parámetro de la declaración GROUP BY como condición de filtrado de datos para obtener los datos que satisfacen la condición de filtrado (que en este caso son los datos en el rango de (2017-11-01T00:00:00, 2019-11-07T23:00:00], y mapee estos datos al eje de tiempo previamente segmentado (en este caso, hay datos mapeados del primer mes en cada período de dos meses desde 2017-11-01T00:00:00 a 2019-11-07T23:00:00).</p>
</div>
<div class="paragraph">
<p>El resultado de la ejecución de SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------------------+
|                         Time|count(root.ln.wf01.wt01.status)|
+-----------------------------+-------------------------------+
|2017-11-01T00:00:00.000+08:00|                            259|
|2018-01-01T00:00:00.000+08:00|                            250|
|2018-03-01T00:00:00.000+08:00|                            259|
|2018-05-01T00:00:00.000+08:00|                            251|
|2018-07-01T00:00:00.000+08:00|                            242|
|2018-09-01T00:00:00.000+08:00|                            225|
|2018-11-01T00:00:00.000+08:00|                            216|
|2019-01-01T00:00:00.000+08:00|                            207|
|2019-03-01T00:00:00.000+08:00|                            216|
|2019-05-01T00:00:00.000+08:00|                            207|
|2019-07-01T00:00:00.000+08:00|                            199|
|2019-09-01T00:00:00.000+08:00|                            181|
|2019-11-01T00:00:00.000+08:00|                             60|
+-----------------------------+-------------------------------+</code></pre>
</div>
</div>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(status) from root.ln.wf01.wt01 group by([2017-10-31T00:00:00, 2019-11-07T23:00:00), 1mo, 2mo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>Dado que el usuario especifica el parámetro de paso deslizante como 2mo, la declaración GROUP BY moverá el intervalo de tiempo a 2 months en lugar de 1 month como predeterminado.</p>
</div>
<div class="paragraph">
<p>El primer parámetro de la declaración GROUP BY anterior es el parámetro de la ventana de visualización, que determina que el rango de visualización final es [2017-10-31T00:00:00, 2019-11-07T23:00:00).</p>
</div>
<div class="paragraph">
<p>A diferencia del ejemplo anterior, la hora de inicio se establece en 2017-10-31T00:00:00. El paso deslizante aumentará mensualmente según la fecha de inicio, y el día 31 del mes, lo que significa que el último día del mes se utilizará como la hora de inicio del intervalo de tiempo. Si la hora de inicio se establece en el día 30, el paso deslizante utilizará el día 30 o el último del mes.</p>
</div>
<div class="paragraph">
<p>La hora de inicio es 2017-10-31T00:00:00. El paso deslizante aumentará mensualmente según la hora de inicio, y el primer día del mes se utilizará como hora de inicio del intervalo de tiempo.</p>
</div>
<div class="paragraph">
<p>El segundo parámetro de la declaración GROUP BY anterior es el intervalo de tiempo para dividir el eje de tiempo. Tomando este parámetro (1mo) como intervalo de tiempo y el startTime de la ventana de visualización como origen de división, el eje de tiempo se divide en varios intervalos continuos, que son [2017-10-31T00:00:00, 2017-11-31T00:00:00), [2018-02-31T00:00:00, 2018-03-31T00:00:00), [2018-05-31T00:00:00, 2018-06-31T00:00:00), etc.</p>
</div>
<div class="paragraph">
<p>El tercer parámetro de la declaración GROUP BY anterior es el paso deslizante para cada intervalo de tiempo que se mueve.</p>
</div>
<div class="paragraph">
<p>Luego, el sistema usará la condición de filtrado de tiempo y valor en la cláusula WHERE y el primer parámetro de la declaración GROUP BY como condición de filtrado de datos para obtener los datos que satisfacen la condición de filtrado (que en este caso son los datos en el rango de [2017-10-31T00:00:00, 2019-11-07T23:00:00) y mapee estos datos al eje de tiempo previamente segmentado (en este caso, hay datos mapeados del primer mes en cada período de dos meses desde 2017-10-31T00:00:00 a 2019-11-07T23:00:00).</p>
</div>
<div class="paragraph">
<p>El resultado de la ejecución de SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------------------+
|                         Time|count(root.ln.wf01.wt01.status)|
+-----------------------------+-------------------------------+
|2017-10-31T00:00:00.000+08:00|                            251|
|2017-12-31T00:00:00.000+08:00|                            250|
|2018-02-28T00:00:00.000+08:00|                            259|
|2018-04-30T00:00:00.000+08:00|                            250|
|2018-06-30T00:00:00.000+08:00|                            242|
|2018-08-31T00:00:00.000+08:00|                            225|
|2018-10-31T00:00:00.000+08:00|                            216|
|2018-12-31T00:00:00.000+08:00|                            208|
|2019-02-28T00:00:00.000+08:00|                            216|
|2019-04-30T00:00:00.000+08:00|                            208|
|2019-06-30T00:00:00.000+08:00|                            199|
|2019-08-31T00:00:00.000+08:00|                            181|
|2019-10-31T00:00:00.000+08:00|                             69|
+-----------------------------+-------------------------------+</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_rango_abierto_izquierdo_y_cerrado_derecho"><a class="anchor" href="#_rango_abierto_izquierdo_y_cerrado_derecho"></a>Rango Abierto Izquierdo y Cerrado Derecho</h5>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(status) from root.ln.wf01.wt01 group by ((2017-11-01T00:00:00, 2017-11-07T23:00:00],1d);</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este sql, el intervalo de tiempo se deja abierto y se cierra a la derecha, por lo que no incluiremos el valor de la marca de tiempo 2017-11-01T00:00:00 y en su lugar incluiremos el valor de la marca de tiempo 2017-11-07T23:00:00.</p>
</div>
<div class="paragraph">
<p>Obtendremos el resultado de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------------------+
|                         Time|count(root.ln.wf01.wt01.status)|
+-----------------------------+-------------------------------+
|2017-11-02T00:00:00.000+08:00|                           1440|
|2017-11-03T00:00:00.000+08:00|                           1440|
|2017-11-04T00:00:00.000+08:00|                           1440|
|2017-11-05T00:00:00.000+08:00|                           1440|
|2017-11-06T00:00:00.000+08:00|                           1440|
|2017-11-07T00:00:00.000+08:00|                           1440|
|2017-11-07T23:00:00.000+08:00|                           1380|
+-----------------------------+-------------------------------+
Total line number = 7
It costs 0.004s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_consulta_agregada_de_frecuencia_descendente_con_cláusula_de_nivel"><a class="anchor" href="#_consulta_agregada_de_frecuencia_descendente_con_cláusula_de_nivel"></a>Consulta Agregada de Frecuencia Descendente con Cláusula de Nivel</h5>
<div class="paragraph">
<p>El nivel podría definirse para mostrar el recuento del número de puntos de cada nodo en el nivel dado en el árbol de metadatos actual.</p>
</div>
<div class="paragraph">
<p>Esto podría usarse para consultar el número de puntos debajo de cada dispositivo.</p>
</div>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="paragraph">
<p>Obtenga consultas agregadas de frecuencia descendente por nivel.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(status) from root.ln.wf01.wt01 group by ((2017-11-01T00:00:00, 2017-11-07T23:00:00],1d), level=1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------------+
|                         Time|COUNT(root.ln.*.*.status)|
+-----------------------------+-------------------------+
|2017-11-02T00:00:00.000+08:00|                     1440|
|2017-11-03T00:00:00.000+08:00|                     1440|
|2017-11-04T00:00:00.000+08:00|                     1440|
|2017-11-05T00:00:00.000+08:00|                     1440|
|2017-11-06T00:00:00.000+08:00|                     1440|
|2017-11-07T00:00:00.000+08:00|                     1440|
|2017-11-07T23:00:00.000+08:00|                     1380|
+-----------------------------+-------------------------+
Total line number = 7
It costs 0.006s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Consulta agregada de frecuencia descendente con paso deslizante y por nivel.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(status) from root.ln.wf01.wt01 group by ([2017-11-01 00:00:00, 2017-11-07 23:00:00), 3h, 1d), level=1;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------------+
|                         Time|COUNT(root.ln.*.*.status)|
+-----------------------------+-------------------------+
|2017-11-01T00:00:00.000+08:00|                      180|
|2017-11-02T00:00:00.000+08:00|                      180|
|2017-11-03T00:00:00.000+08:00|                      180|
|2017-11-04T00:00:00.000+08:00|                      180|
|2017-11-05T00:00:00.000+08:00|                      180|
|2017-11-06T00:00:00.000+08:00|                      180|
|2017-11-07T00:00:00.000+08:00|                      180|
+-----------------------------+-------------------------+
Total line number = 7
It costs 0.004s</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_consulta_agregada_de_frecuencia_descendente_con_cláusula_de_relleno"><a class="anchor" href="#_consulta_agregada_de_frecuencia_descendente_con_cláusula_de_relleno"></a>Consulta Agregada de Frecuencia Descendente con Cláusula de Relleno</h5>
<div class="paragraph">
<p>En grupo por relleno, el paso deslizante no se admite e grupo por la claúsula.</p>
</div>
<div class="paragraph">
<p>Ahora, solo la función de agregación last_value es compatible en grupo por relleno.</p>
</div>
<div class="paragraph">
<p>El relleno lineal no se admite en el grupo por relleno.</p>
</div>
<div class="sect5">
<h6 id="_diferencia_entre_previousuntillast_y_previous"><a class="anchor" href="#_diferencia_entre_previousuntillast_y_previous"></a>Diferencia Entre PREVIOUSUNTILLAST y PREVIOUS</h6>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>PREVIOUS llenará cualquier valor nulo siempre que el valor existente no sea nulo antes.</p>
</li>
<li>
<p>PREVIOUSUNTILLAST no completará el resultado cuya hora sea posterior a la última hora de esa serie temporal.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Primero, verificamos el valor root.ln.wf01.wt01.temperature cuando el tiempo después de 2017-11-07T23:50:00.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>IoTDB&gt; SELECT temperature FROM root.ln.wf01.wt01 where time &gt;= 2017-11-07T23:50:00
+-----------------------------+-----------------------------+
|                         Time|root.ln.wf01.wt01.temperature|
+-----------------------------+-----------------------------+
|2017-11-07T23:50:00.000+08:00|                         23.7|
|2017-11-07T23:51:00.000+08:00|                        22.24|
|2017-11-07T23:52:00.000+08:00|                        20.18|
|2017-11-07T23:53:00.000+08:00|                        24.58|
|2017-11-07T23:54:00.000+08:00|                        22.52|
|2017-11-07T23:55:00.000+08:00|                         25.9|
|2017-11-07T23:56:00.000+08:00|                        24.44|
|2017-11-07T23:57:00.000+08:00|                        24.39|
|2017-11-07T23:58:00.000+08:00|                        22.93|
|2017-11-07T23:59:00.000+08:00|                        21.07|
+-----------------------------+-----------------------------+
Total line number = 10
It costs 0.002s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Encontraremos que la última hora y el valor de root.ln.wf01.wt01.temperature son 2017-11-07T23:59:00 y 21.07 respectivamente.</p>
</div>
<div class="paragraph">
<p>Luego ejecute declaraciones SQL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>SELECT last_value(temperature) FROM root.ln.wf01.wt01 GROUP BY([2017-11-07T23:50:00, 2017-11-08T00:01:00),1m) FILL (float[PREVIOUSUNTILLAST]);
SELECT last_value(temperature) FROM root.ln.wf01.wt01 GROUP BY([2017-11-07T23:50:00, 2017-11-08T00:01:00),1m) FILL (float[PREVIOUS]);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Resultado:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-----------------------------------------+
|                         Time|last_value(root.ln.wf01.wt01.temperature)|
+-----------------------------+-----------------------------------------+
|2017-11-07T23:50:00.000+08:00|                                     23.7|
|2017-11-07T23:51:00.000+08:00|                                    22.24|
|2017-11-07T23:52:00.000+08:00|                                    20.18|
|2017-11-07T23:53:00.000+08:00|                                    24.58|
|2017-11-07T23:54:00.000+08:00|                                    22.52|
|2017-11-07T23:55:00.000+08:00|                                     25.9|
|2017-11-07T23:56:00.000+08:00|                                    24.44|
|2017-11-07T23:57:00.000+08:00|                                    24.39|
|2017-11-07T23:58:00.000+08:00|                                    22.93|
|2017-11-07T23:59:00.000+08:00|                                    21.07|
|2017-11-08T00:00:00.000+08:00|                                     null|
+-----------------------------+-----------------------------------------+
Total line number = 11
It costs 0.005s

+-----------------------------+-----------------------------------------+
|                         Time|last_value(root.ln.wf01.wt01.temperature)|
+-----------------------------+-----------------------------------------+
|2017-11-07T23:50:00.000+08:00|                                     23.7|
|2017-11-07T23:51:00.000+08:00|                                    22.24|
|2017-11-07T23:52:00.000+08:00|                                    20.18|
|2017-11-07T23:53:00.000+08:00|                                    24.58|
|2017-11-07T23:54:00.000+08:00|                                    22.52|
|2017-11-07T23:55:00.000+08:00|                                     25.9|
|2017-11-07T23:56:00.000+08:00|                                    24.44|
|2017-11-07T23:57:00.000+08:00|                                    24.39|
|2017-11-07T23:58:00.000+08:00|                                    22.93|
|2017-11-07T23:59:00.000+08:00|                                    21.07|
|2017-11-08T00:00:00.000+08:00|                                    21.07|
+-----------------------------+-----------------------------------------+
Total line number = 11
It costs 0.006s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>El uso de PREVIOUSUNTILLAST no llenará el tiempo después de 2017-11-07T23:59.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="_consulta_de_último_punto" class="sect0"><a class="anchor" href="#_consulta_de_último_punto"></a>Consulta de Último Punto</h1>
<div class="paragraph">
<p>En escenarios en los que los dispositivos de IoT actualizan los datos de manera rápida, los usuarios están más interesados ​​en el punto más reciente de los dispositivos de IoT.</p>
</div>
<div class="paragraph">
<p>La consulta del último punto es devolver el punto de datos más reciente de la serie temporal dada en un formato de tres columnas.</p>
</div>
<div class="paragraph">
<p>La declaración SQL se define como:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select last &lt;Path&gt; [COMMA &lt;Path&gt;]* from &lt; PrefixPath &gt; [COMMA &lt; PrefixPath &gt;]* &lt;WhereClause&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa: consulta y devuelve los últimos puntos de datos de la serie temporal prefixPath.path.</p>
</div>
<div class="paragraph">
<p>Solo el filtro de tiempo con '&gt;' o '&gt;=' es compatible con &lt;WhereClause&gt;. Cualquier otro filtro dado en &lt;WhereClause&gt; dará una excepción.</p>
</div>
<div class="paragraph">
<p>El resultado se devolverá en un formato de tabla de tres columnas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>| Time | Path | Value |</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ejemplo 1: obtenga el último punto de root.ln.wf01.wt01.status:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>IoTDB&gt; select last status from root.ln.wf01.wt01
+-----------------------------+------------------------+-----+
|                         Time|              timeseries|value|
+-----------------------------+------------------------+-----+
|2017-11-07T23:59:00.000+08:00|root.ln.wf01.wt01.status|false|
+-----------------------------+------------------------+-----+
Total line number = 1
It costs 0.000s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ejemplo 2: obtenga los últimos puntos de estado y temperatura de root.ln.wf01.wt01, cuya marca de tiempo sea mayor o igual a 2017-11-07T23:50:00.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>IoTDB&gt; select last status, temperature from root.ln.wf01.wt01 where time &gt;= 2017-11-07T23:50:00
+-----------------------------+-----------------------------+---------+
|                         Time|                   timeseries|    value|
+-----------------------------+-----------------------------+---------+
|2017-11-07T23:59:00.000+08:00|     root.ln.wf01.wt01.status|    false|
|2017-11-07T23:59:00.000+08:00|root.ln.wf01.wt01.temperature|21.067368|
+-----------------------------+-----------------------------+---------+
Total line number = 2
It costs 0.002s</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_relleno_automatizado"><a class="anchor" href="#_relleno_automatizado"></a>Relleno Automatizado</h4>
<div class="paragraph">
<p>En el uso real de IoTDB, al realizar la operación de consulta de series temporales, pueden aparecer situaciones en las que el valor es nulo en algunos momentos, lo que obstaculizará el análisis posterior por parte de los usuarios. Para reflejar mejor el grado de cambio de datos, los usuarios esperan que los valores faltantes se completen automáticamente. Por lo tanto, el sistema IoTDB introduce la función de Relleno Automatizado.</p>
</div>
<div class="paragraph">
<p>La función de relleno automatizado se refiere al relleno de valores vacíos de acuerdo con el método especificado por el usuario y el rango de tiempo efectivo al realizar consultas de series temporales para una o varias columnas. Si el valor del punto consultado no es nulo, la función de relleno no funcionará.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En la versión actual, IoTDB proporciona a los usuarios dos métodos: anterior y lineal. El método anterior llena los espacios en blanco con el valor anterior. El método lineal llena los espacios en blanco mediante un ajuste lineal. Y la función de relleno solo se puede utilizar cuando se realizan consultas en un momento determinado.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="_función_fill"><a class="anchor" href="#_función_fill"></a>Función Fill</h5>
<div class="sect5">
<h6 id="_función_anterior"><a class="anchor" href="#_función_anterior"></a>Función Anterior</h6>
<div class="paragraph">
<p>Cuando el valor de la marca de tiempo consultada es nulo, el valor de la marca de tiempo anterior se usa para llenar el espacio en blanco. El método anterior formalizado es el siguiente (consulte la Sección 7.1.3.6 para ver la sintaxis detallada):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select &lt;path&gt; from &lt;prefixPath&gt; where time = &lt;T&gt; fill(&lt;data_type&gt;[previous, &lt;before_range&gt;], …)</code></pre>
</div>
</div>
<div class="paragraph">
<p>En la Tabla 3-4 se dan descripciones detalladas de todos los parámetros.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Tabla 3-4 Lista de parámetros de relleno anterior</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nombre del parámetro (no distingue entre mayúsculas y minúsculas)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpretación</p>
<p class="tableblock">path, prefixPath
Ruta de consulta; campo obligatorio</p>
<p class="tableblock">T
Marca de tiempo de la consulta (solo se puede especificar una); campo obligatorio</p>
<p class="tableblock">data_type
El tipo de datos utilizados por el método de relleno. Los valores opcionales son int32, int64, float, double, boolean, text; campo opcional</p>
<p class="tableblock">before_range
Representa el intervalo de tiempo válido del método anterior. El método anterior funciona cuando hay valores en el rango [T-before_range, T]. Cuando no se especifica before_range, before_range toma el valor predeterminado default_fill_interval; -1 representa infinito; campo opcional</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Aquí damos un ejemplo de relleno de valores nulos usando el método anterior. La declaración SQL escomo sigue:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select temperature from root.sgcc.wf03.wt01 where time = 2017-11-01T16:37:50.000 fill(float[previous, 1s])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>Debido a que la serie temporal root.sgcc.wf03.wt01.temperature es nula en 2017-11-01T16:37:50.000, el sistema usa la marca de tiempo anterior 2017-11-01T16:37:00.000 (y la marca de tiempo está en el intervalo de tiempo [2017-11-01T16:36:50.000, 2017-11-01T16:37:50.000]) para relleno y visualización.</p>
</div>
<div class="paragraph">
<p>En los [datos de muestra], el resultado de la ejecución de esta declaración se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------------------+
|                         Time|root.sgcc.wf03.wt01.temperature|
+-----------------------------+-------------------------------+
|2017-11-01T16:37:50.000+08:00|                          21.93|
+-----------------------------+-------------------------------+
Total line number = 1
It costs 0.016s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vale la pena señalar que si no hay ningún valor en el rango de tiempo válido especificado, el sistema no completará el valor nulo, como se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>IoTDB&gt; select temperature from root.sgcc.wf03.wt01 where time = 2017-11-01T16:37:50.000 fill(float[previous, 1s])
+-----------------------------+-------------------------------+
|                         Time|root.sgcc.wf03.wt01.temperature|
+-----------------------------+-------------------------------+
|2017-11-01T16:37:50.000+08:00|                           null|
+-----------------------------+-------------------------------+
Total line number = 1
It costs 0.004s</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_método_lineal"><a class="anchor" href="#_método_lineal"></a>Método Lineal</h6>
<div class="paragraph">
<p>Cuando el valor de la marca de tiempo consultada es nulo, el valor de la marca de tiempo anterior y siguiente se usa para llenar el espacio en blanco. El método lineal formalizado es el siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select &lt;path&gt; from &lt;prefixPath&gt; where time = &lt;T&gt; fill(&lt;data_type&gt;[linear, &lt;before_range&gt;, &lt;after_range&gt;]…)</code></pre>
</div>
</div>
<div class="paragraph">
<p>En la Tabla 3-5 se dan descripciones detalladas de todos los parámetros.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Tabla 3-5 Lista de parámetros de relleno lineal</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nombre del parámetro (no distingue entre mayúsculas y minúsculas)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interpretación</p>
<p class="tableblock">path, prefixPath
ruta de consulta; campo obligatorio</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">T</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">marca de tiempo de la consulta (solo se puede especificar una); campo obligatorio</p>
<p class="tableblock">data_type
el tipo de datos utilizados por el método de relleno. Los valores opcionales son int32, int64, float, double, boolean, text; campo opcional</p>
<p class="tableblock">before_range, after_range
representa el rango de tiempo válido del método lineal. El método anterior funciona cuando hay valores en el rango [T-before_range, T+after_range]. Cuando before_range y after_range no se especifican explícitamente, se utiliza default_fill_interval. -1 representa infinito; campo opcional</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Tenga en cuenta que si la serie temporal tiene un valor válido en la marca de tiempo de la consulta T, este valor se utilizará como valor de relleno lineal. De lo contrario, si no hay un valor de relleno válido en el rango [T-before_range，T] o [T,T + after_range], el método de relleno lineal devolverá un valor nulo.</p>
</div>
<div class="paragraph">
<p>Aquí damos un ejemplo de relleno de valores nulos usando el método lineal. La declaración SQL es la siguiente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select temperature from root.sgcc.wf03.wt01 where time = 2017-11-01T16:37:50.000 fill(float [linear, 1m, 1m])</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>Debido a que la serie temporal root.sgcc.wf03.wt01.temperature es nula en 2017-11-01T16:37:50.000, el sistema usa la marca de tiempo anterior 2017-11-01T16:37:00.000 (y la marca de tiempo está en el intervalo de tiempo [2017-11-01T16:36:50.000, 2017-11-01T16:37:50.000]) y su valor 21.927326, la siguiente marca de tiempo 2017-11-01T16: 38: 00.000 (y la marca de tiempo está en el  rango de tiempo [2017-11- 01T16: 37: 50.000, 2017-11-01T16: 38: 50.000]) y su valor 25.311783 para realizar el cálculo de ajuste lineal: 21.927326 + (25.311783-21.927326)/60s * 50s = 24.747707</p>
</div>
<div class="paragraph">
<p>En los [datos de muestra], el resultado de la ejecución de esta declaración se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------------------+
|                         Time|root.sgcc.wf03.wt01.temperature|
+-----------------------------+-------------------------------+
|2017-11-01T16:37:50.000+08:00|                      24.746666|
+-----------------------------+-------------------------------+
Total line number = 1
It costs 0.017s</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_correspondencia_entre_el_tipo_de_datos_y_el_método_de_relleno"><a class="anchor" href="#_correspondencia_entre_el_tipo_de_datos_y_el_método_de_relleno"></a>Correspondencia Entre el Tipo de Datos y el Método de Relleno</h5>
<div class="paragraph">
<p>Los tipos de datos y los métodos de relleno admitidos se muestran en la Tabla 3-6.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Tabla 3-6 Tipos de datos y métodos de relleno admitidos</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipo de Datos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Métodos de Relleno Admitidos</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior, lineal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior, lineal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">flotar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior, lineal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">doble</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior, lineal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">texto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Cuando no se especifica el método de relleno, cada tipo de datos tiene sus propios métodos y parámetros de relleno predeterminados. La relación correspondiente se muestra en la Tabla 3-7.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Tabla 3-7 Métodos y parámetros de relleno predeterminados para varios tipos de datos</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipo de Datos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parámetros y Métodos de Relleno Predeterminados</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boolean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior, 600000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior, 600000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">int64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior, 600000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">flotador</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior, 600000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">doble</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior, 600000</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">texto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">anterior, 600000</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>En la versión 0.7.0, se debe especificar al menos un método de relleno en la declaración de relleno.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_control_de_filas_y_columnas_sobre_los_resultados_de_la_consulta"><a class="anchor" href="#_control_de_filas_y_columnas_sobre_los_resultados_de_la_consulta"></a>Control de Filas y Columnas Sobre los Resultados de la Consulta</h4>
<div class="paragraph">
<p>IoTDB proporciona una cláusula [LIMIT/SLIMIT] y una cláusula [OFFSET/SOFFSET] para que los usuarios tengan más control sobre los resultados de las consultas. El uso de cláusulas LIMIT y SLIMIT permite a los usuarios controlar el número de filas y columnas de los resultados de la consulta, y el uso de cláusulas OFFSET y SOFSET permite a los usuarios establecer la posición inicial de los resultados para su visualización.</p>
</div>
<div class="paragraph">
<p>Tenga en cuenta que LIMIT y OFFSET no se admiten en grupo por consulta.</p>
</div>
<div class="paragraph">
<p>Este capítulo presenta principalmente ejemplos relacionados de control de filas y columnas de resultados de consultas. También puede utilizar la interfaz estándar de [Java JDBC] para ejecutar consultas.</p>
</div>
<div class="sect4">
<h5 id="_control_de_filas_y_columnas_sobre_los_resultados_de_la_consulta_2"><a class="anchor" href="#_control_de_filas_y_columnas_sobre_los_resultados_de_la_consulta_2"></a>Control de Filas y Columnas Sobre los Resultados de la Consulta</h5>
<div class="paragraph">
<p>Mediante el uso de cláusulas LIMIT y OFFSET, los usuarios controlan los resultados de la consulta de una manera relacionada con las filas. Demostramos cómo usar las cláusulas LIMIT y OFFSET a través de los siguientes ejemplos.</p>
</div>
<div class="sect5">
<h6 id="_ejemplo_1_cláusula_limit_básica"><a class="anchor" href="#_ejemplo_1_cláusula_limit_básica"></a>Ejemplo 1: cláusula LIMIT básica</h6>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select status, temperature from root.ln.wf01.wt01 limit 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>El dispositivo seleccionado es en el grupo wf01 plant wt01 device; la serie de tiempo seleccionada es "status" y "temperature". La declaración SQL requiere las primeras 10 filas del resultado de la consulta.</p>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+------------------------+-----------------------------+
|                         Time|root.ln.wf01.wt01.status|root.ln.wf01.wt01.temperature|
+-----------------------------+------------------------+-----------------------------+
|2017-11-01T00:00:00.000+08:00|                    true|                        25.96|
|2017-11-01T00:01:00.000+08:00|                    true|                        24.36|
|2017-11-01T00:02:00.000+08:00|                   false|                        20.09|
|2017-11-01T00:03:00.000+08:00|                   false|                        20.18|
|2017-11-01T00:04:00.000+08:00|                   false|                        21.13|
|2017-11-01T00:05:00.000+08:00|                   false|                        22.72|
|2017-11-01T00:06:00.000+08:00|                   false|                        20.71|
|2017-11-01T00:07:00.000+08:00|                   false|                        21.45|
|2017-11-01T00:08:00.000+08:00|                   false|                        22.58|
|2017-11-01T00:09:00.000+08:00|                   false|                        20.98|
+-----------------------------+------------------------+-----------------------------+
Total line number = 10
It costs 0.000s</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_ejemplo_2_cláusula_limit_con_offset"><a class="anchor" href="#_ejemplo_2_cláusula_limit_con_offset"></a>Ejemplo 2: cláusula LIMIT con OFFSET</h6>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select status, temperature from root.ln.wf01.wt01 limit 5 offset 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>El dispositivo seleccionado es en el grupo wf01 plant wt01 device; la serie de tiempo seleccionada es "status" y "temperaturw". La declaración SQL requiere que se devuelvan las filas 3 a 7 del resultado de la consulta (con la primera fila numerada como fila 0).</p>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+------------------------+-----------------------------+
|                         Time|root.ln.wf01.wt01.status|root.ln.wf01.wt01.temperature|
+-----------------------------+------------------------+-----------------------------+
|2017-11-01T00:03:00.000+08:00|                   false|                        20.18|
|2017-11-01T00:04:00.000+08:00|                   false|                        21.13|
|2017-11-01T00:05:00.000+08:00|                   false|                        22.72|
|2017-11-01T00:06:00.000+08:00|                   false|                        20.71|
|2017-11-01T00:07:00.000+08:00|                   false|                        21.45|
+-----------------------------+------------------------+-----------------------------+
Total line number = 5
It costs 0.342s</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_ejemplo_3_cláusula_limit_combinada_con_cláusula_where"><a class="anchor" href="#_ejemplo_3_cláusula_limit_combinada_con_cláusula_where"></a>Ejemplo 3: cláusula LIMIT combinada con cláusula WHERE</h6>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select status,temperature from root.ln.wf01.wt01 where time &gt; 2017-11-01T00:05:00.000 and time&lt; 2017-11-01T00:12:00.000 limit 2 offset 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>El dispositivo seleccionado es en el grupo wf01 plant wt01 device; la serie de tiempo seleccionada es "status" y "temperature". La declaración SQL requiere filas 3 a 4 de los valores del sensor de temperatura y estado entre el punto de tiempo de "2017-11-01T00:05:00.000" y "2017-11-01T00:12:00.000" (con la primera fila numerada como fila 0).</p>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+------------------------+-----------------------------+
|                         Time|root.ln.wf01.wt01.status|root.ln.wf01.wt01.temperature|
+-----------------------------+------------------------+-----------------------------+
|2017-11-01T00:03:00.000+08:00|                   false|                        20.18|
|2017-11-01T00:04:00.000+08:00|                   false|                        21.13|
|2017-11-01T00:05:00.000+08:00|                   false|                        22.72|
|2017-11-01T00:06:00.000+08:00|                   false|                        20.71|
|2017-11-01T00:07:00.000+08:00|                   false|                        21.45|
+-----------------------------+------------------------+-----------------------------+
Total line number = 5
It costs 0.000s</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_ejemplo_4_cláusula_limit_combinada_con_cláusula_group_by"><a class="anchor" href="#_ejemplo_4_cláusula_limit_combinada_con_cláusula_group_by"></a>Ejemplo 4: cláusula LIMIT combinada con cláusula GROUP BY</h6>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select count(status), max_value(temperature) from root.ln.wf01.wt01 group by ([2017-11-01T00:00:00, 2017-11-07T23:00:00),1d) limit 5 offset 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>La cláusula de declaración SQL requiere que se devuelvan las filas 3 a 7 del resultado de la consulta (con la primera fila numerada como fila 0).</p>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-------------------------------+----------------------------------------+
|                         Time|count(root.ln.wf01.wt01.status)|max_value(root.ln.wf01.wt01.temperature)|
+-----------------------------+-------------------------------+----------------------------------------+
|2017-11-04T00:00:00.000+08:00|                           1440|                                    26.0|
|2017-11-05T00:00:00.000+08:00|                           1440|                                    26.0|
|2017-11-06T00:00:00.000+08:00|                           1440|                                   25.99|
|2017-11-07T00:00:00.000+08:00|                           1380|                                    26.0|
+-----------------------------+-------------------------------+----------------------------------------+
Total line number = 4
It costs 0.016s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vale la pena señalar que debido a que la cláusula FILL actual solo puede completar el valor faltante de las series temporales en un momento determinado, es decir, el resultado de la ejecución de la cláusula FILL es exactamente una línea, por lo que no se espera que LIMIT y OFFSET sean utilizados en combinación con la cláusula FILL; de lo contrario, se generarán errores. Por ejemplo, ejecutando la siguiente declaración SQL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select temperature from root.sgcc.wf03.wt01 where time = 2017-11-01T16:37:50.000 fill(float[previous, 1m]) limit 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>La declaración SQL no se ejecutará y el mensaje de error correspondiente se proporciona de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Msg: 401: line 1:107 mismatched input 'limit' expecting {&lt;EOF&gt;, SLIMIT, SOFFSET, GROUP, DISABLE, ALIGN}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_control_de_columna_sobre_los_resultados_de_la_consulta"><a class="anchor" href="#_control_de_columna_sobre_los_resultados_de_la_consulta"></a>Control de Columna Sobre los Resultados de la Consulta</h5>
<div class="paragraph">
<p>Mediante el uso de cláusulas SLIMIT y SOFFSET, los usuarios pueden controlar los resultados de la consulta de una manera relacionada con las columnas. Demostraremos cómo utilizar las cláusulas SLIMIT y SOFFSET a través de los siguientes ejemplos.</p>
</div>
<div class="sect5">
<h6 id="_ejemplo_1_cláusula_slimit_básica"><a class="anchor" href="#_ejemplo_1_cláusula_slimit_básica"></a>Ejemplo 1: cláusula SLIMIT básica</h6>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select * from root.ln.wf01.wt01 where time &gt; 2017-11-01T00:05:00.000 and time &lt; 2017-11-01T00:12:00.000 slimit 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>El dispositivo seleccionado es en el grupo wf01 plant wt01 device; la serie de tiempo seleccionada es la primera columna debajo de este dispositivo, es decir, el estado de la fuente de alimentación. La declaración SQL requiere que se seleccionen los valores del sensor de estado entre el punto de tiempo "2017-11-01T00:05:00.000" y "2017-11-01T00:12:00.000".</p>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-----------------------------+
|                         Time|root.ln.wf01.wt01.temperature|
+-----------------------------+-----------------------------+
|2017-11-01T00:06:00.000+08:00|                        20.71|
|2017-11-01T00:07:00.000+08:00|                        21.45|
|2017-11-01T00:08:00.000+08:00|                        22.58|
|2017-11-01T00:09:00.000+08:00|                        20.98|
|2017-11-01T00:10:00.000+08:00|                        25.52|
|2017-11-01T00:11:00.000+08:00|                        22.91|
+-----------------------------+-----------------------------+
Total line number = 6
It costs 0.000s</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_ejemplo_2_cláusula_slimit_con_soffset"><a class="anchor" href="#_ejemplo_2_cláusula_slimit_con_soffset"></a>Ejemplo 2: cláusula SLIMIT con SOFFSET</h6>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select * from root.ln.wf01.wt01 where time &gt; 2017-11-01T00:05:00.000 and time &lt; 2017-11-01T00:12:00.000 slimit 1 soffset 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>El dispositivo seleccionado es en el grupo wf01 plant wt01 device; la serie temporal seleccionada es la segunda columna de este dispositivo, es decir, la temperatura. La declaración SQL requiere que se seleccionen los valores del sensor de temperatura entre el punto de tiempo "2017-11-01T00:05:00.000" y "2017-11-01T00:12:00.000".</p>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+------------------------+
|                         Time|root.ln.wf01.wt01.status|
+-----------------------------+------------------------+
|2017-11-01T00:06:00.000+08:00|                   false|
|2017-11-01T00:07:00.000+08:00|                   false|
|2017-11-01T00:08:00.000+08:00|                   false|
|2017-11-01T00:09:00.000+08:00|                   false|
|2017-11-01T00:10:00.000+08:00|                    true|
|2017-11-01T00:11:00.000+08:00|                   false|
+-----------------------------+------------------------+
Total line number = 6
It costs 0.003s</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_ejemplo_3_cláusula_slimit_combinada_con_cláusula_group_by"><a class="anchor" href="#_ejemplo_3_cláusula_slimit_combinada_con_cláusula_group_by"></a>Ejemplo 3: cláusula SLIMIT combinada con cláusula GROUP BY</h6>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select max_value(*) from root.ln.wf01.wt01 group by ([2017-11-01T00:00:00, 2017-11-07T23:00:00),1d) slimit 1 soffset 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-----------------------------------+
|                         Time|max_value(root.ln.wf01.wt01.status)|
+-----------------------------+-----------------------------------+
|2017-11-01T00:00:00.000+08:00|                               true|
|2017-11-02T00:00:00.000+08:00|                               true|
|2017-11-03T00:00:00.000+08:00|                               true|
|2017-11-04T00:00:00.000+08:00|                               true|
|2017-11-05T00:00:00.000+08:00|                               true|
|2017-11-06T00:00:00.000+08:00|                               true|
|2017-11-07T00:00:00.000+08:00|                               true|
+-----------------------------+-----------------------------------+
Total line number = 7
It costs 0.000s</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_ejemplo_4_cláusula_slimit_combinada_con_cláusula_fill"><a class="anchor" href="#_ejemplo_4_cláusula_slimit_combinada_con_cláusula_fill"></a>Ejemplo 4: cláusula SLIMIT combinada con cláusula FILL</h6>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select * from root.sgcc.wf03.wt01 where time = 2017-11-01T16:35:00 fill(float[previous, 1m]) slimit 1 soffset 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>El dispositivo seleccionado es en el grupo wf01 plant wt01 device; la serie temporal seleccionada es la segunda columna de este dispositivo, es decir, la temperatura.</p>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+--------------------------+
|                         Time|root.sgcc.wf03.wt01.status|
+-----------------------------+--------------------------+
|2017-11-01T16:35:00.000+08:00|                      true|
+-----------------------------+--------------------------+
Total line number = 1
It costs 0.007s</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_control_de_filas_y_columnas_sobre_los_resultados_de_la_consulta_3"><a class="anchor" href="#_control_de_filas_y_columnas_sobre_los_resultados_de_la_consulta_3"></a>Control de Filas y Columnas Sobre los Resultados de la Consulta</h5>
<div class="paragraph">
<p>Además del control de filas o columnas sobre los resultados de las consultas, IoTDB permite a los usuarios controlar tanto las filas como las columnas de los resultados de las consultas. Aquí hay un ejemplo completo con cláusulas LIMIT y cláusulas SLIMIT.</p>
</div>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select * from root.ln.wf01.wt01 limit 10 offset 100 slimit 2 soffset 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Lo que significa:</p>
</div>
<div class="paragraph">
<p>El dispositivo seleccionado es en el grupo wf01 plant wt01 device; la serie de tiempo seleccionada son las columnas 0 a 1 bajo este dispositivo (con la primera columna numerada como columna 0). La cláusula de declaración SQL requiere que se devuelvan las filas 100 a 109 del resultado de la consulta (con la primera fila numerada como fila 0).</p>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-----------------------------+------------------------+
|                         Time|root.ln.wf01.wt01.temperature|root.ln.wf01.wt01.status|
+-----------------------------+-----------------------------+------------------------+
|2017-11-01T01:40:00.000+08:00|                        21.19|                   false|
|2017-11-01T01:41:00.000+08:00|                        22.79|                   false|
|2017-11-01T01:42:00.000+08:00|                        22.98|                   false|
|2017-11-01T01:43:00.000+08:00|                        21.52|                   false|
|2017-11-01T01:44:00.000+08:00|                        23.45|                    true|
|2017-11-01T01:45:00.000+08:00|                        24.06|                    true|
|2017-11-01T01:46:00.000+08:00|                         22.6|                   false|
|2017-11-01T01:47:00.000+08:00|                        23.78|                    true|
|2017-11-01T01:48:00.000+08:00|                        24.72|                    true|
|2017-11-01T01:49:00.000+08:00|                        24.68|                    true|
+-----------------------------+-----------------------------+------------------------+
Total line number = 10
It costs 0.009s</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_utilizar_alias"><a class="anchor" href="#_utilizar_alias"></a>Utilizar Alias</h4>
<div class="paragraph">
<p>Dado que el modelo de datos único de IoTDB, se llevará mucha información adicional como dispositivo antes de cada sensor. A veces, queremos consultar solo un dispositivo específico, entonces esta información de prefijo que se muestra con frecuencia será redundante en esta situación, lo que influirá en el análisis del conjunto de resultados. En este momento, podemos usar la función <code>AS</code> proporcionada por IoTDB, asignar un alias a la serie de tiempo seleccionada en la consulta.</p>
</div>
<div class="paragraph">
<p>Por ejemplo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select s1 as temperature, s2 as speed from root.ln.wf01.wt01;</code></pre>
</div>
</div>
<div class="paragraph">
<p>El conjunto de resultados es:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tiempo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Temperatura</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Velocidad</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8230;&#8203;</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_otro_formato_resultset"><a class="anchor" href="#_otro_formato_resultset"></a>Otro Formato ResultSet</h5>
<div class="paragraph">
<p>Además, IoTDB admite otros dos formatos de conjuntos de resultados: 'alinear por dispositivo' y 'deshabilitar alineación'.</p>
</div>
<div class="paragraph">
<p>El 'alinear por dispositivo' indica que el deviceId se considera como una columna. Por lo tanto, hay columnas totalmente limitadas en el conjunto de datos.</p>
</div>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select * from root.ln.* where time &lt;= 2017-11-01T00:01:00 align by device</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+-----------------+-----------+------+--------+
|                         Time|           Device|temperature|status|hardware|
+-----------------------------+-----------------+-----------+------+--------+
|2017-11-01T00:00:00.000+08:00|root.ln.wf01.wt01|      25.96|  true|    null|
|2017-11-01T00:01:00.000+08:00|root.ln.wf01.wt01|      24.36|  true|    null|
|1970-01-01T08:00:00.001+08:00|root.ln.wf02.wt02|       null|  true|      v1|
|1970-01-01T08:00:00.002+08:00|root.ln.wf02.wt02|       null| false|      v2|
|2017-11-01T00:00:00.000+08:00|root.ln.wf02.wt02|       null|  true|      v2|
|2017-11-01T00:01:00.000+08:00|root.ln.wf02.wt02|       null|  true|      v2|
+-----------------------------+-----------------+-----------+------+--------+
Total line number = 6
It costs 0.012s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para obtener más descripción de la sintaxis, lea [Referencia de SQL].</p>
</div>
<div class="paragraph">
<p>La 'deshabilitar alineación' indica que hay 2 columnas para cada serie de tiempo en el conjunto de resultados. La Cláusula Deshabilitar Alineación solo se puede utilizar al final de una declaración de consulta. La Cláusula Deshabilitar Alineación no se puede usar con Agregación, Declaraciones de Relleno, Declaraciones de Agrupar Por o de Agrupar Por Dispositivo, pero sí con Declaraciones de Límite. El principio de visualización de la tabla de resultados es que solo cuando la columna (o fila) tenga datos existentes, se mostrará la columna (o fila), y las celdas inexistentes estarán vacías.</p>
</div>
<div class="paragraph">
<p>La declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>select * from root.ln.* where time &lt;= 2017-11-01T00:01:00 disable align</pre>
</div>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>+-----------------------------+--------------------------+-----------------------------+------------------------+-----------------------------+-----------------------------+-----------------------------+------------------------+
|                         Time|root.ln.wf02.wt02.hardware|                         Time|root.ln.wf02.wt02.status|                         Time|root.ln.wf01.wt01.temperature|                         Time|root.ln.wf01.wt01.status|
+-----------------------------+--------------------------+-----------------------------+------------------------+-----------------------------+-----------------------------+-----------------------------+------------------------+
|1970-01-01T08:00:00.001+08:00|                        v1|1970-01-01T08:00:00.001+08:00|                    true|2017-11-01T00:00:00.000+08:00|                        25.96|2017-11-01T00:00:00.000+08:00|                    true|
|1970-01-01T08:00:00.002+08:00|                        v2|1970-01-01T08:00:00.002+08:00|                   false|2017-11-01T00:01:00.000+08:00|                        24.36|2017-11-01T00:01:00.000+08:00|                    true|
|2017-11-01T00:00:00.000+08:00|                        v2|2017-11-01T00:00:00.000+08:00|                    true|                         null|                         null|                         null|                    null|
|2017-11-01T00:01:00.000+08:00|                        v2|2017-11-01T00:01:00.000+08:00|                    true|                         null|                         null|                         null|                    null|
+-----------------------------+--------------------------+-----------------------------+------------------------+-----------------------------+-----------------------------+-----------------------------+------------------------+
Total line number = 4
It costs 0.018s</pre>
</div>
</div>
<div class="paragraph">
<p>Para obtener más descripción de la sintaxis, lea [Referencia de SQL].</p>
</div>
</div>
<div class="sect4">
<h5 id="_manejo_de_errores"><a class="anchor" href="#_manejo_de_errores"></a>Manejo de Errores</h5>
<div class="paragraph">
<p>Si el parámetro N/SN de LIMIT/SLIMIT excede el tamaño del conjunto de resultados, IoTDB devuelve todos los resultados como se esperaba. Por ejemplo, el resultado de la consulta de la declaración SQL original consta de seis filas, y seleccionamos las primeras 100 filas a través de la cláusula LIMIT:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select status,temperature from root.ln.wf01.wt01 where time &gt; 2017-11-01T00:05:00.000 and time &lt; 2017-11-01T00:12:00.000 limit 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+-----------------------------+------------------------+-----------------------------+
|                         Time|root.ln.wf01.wt01.status|root.ln.wf01.wt01.temperature|
+-----------------------------+------------------------+-----------------------------+
|2017-11-01T00:06:00.000+08:00|                   false|                        20.71|
|2017-11-01T00:07:00.000+08:00|                   false|                        21.45|
|2017-11-01T00:08:00.000+08:00|                   false|                        22.58|
|2017-11-01T00:09:00.000+08:00|                   false|                        20.98|
|2017-11-01T00:10:00.000+08:00|                    true|                        25.52|
|2017-11-01T00:11:00.000+08:00|                   false|                        22.91|
+-----------------------------+------------------------+-----------------------------+
Total line number = 6
It costs 0.005s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el parámetro N/SN de la cláusula LIMIT/SLIMIT excede el valor máximo permitido (N/SN es del tipo int32), el sistema muestra errores. Por ejemplo, ejecutando la siguiente declaración SQL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select status,temperature from root.ln.wf01.wt01 where time &gt; 2017-11-01T00:05:00.000 and time &lt; 2017-11-01T00:12:00.000 limit 1234567890123456789</code></pre>
</div>
</div>
<div class="paragraph">
<p>La declaración SQL no se ejecutará y el mensaje de error correspondiente se proporciona de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Msg: 303: check metadata error: Out of range. LIMIT &lt;N&gt;: N should be Int32.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el parámetro N/SN de la cláusula LIMIT/SLIMIT no es un número entero positivo, el sistema muestra errores. Por ejemplo, ejecutando la siguiente declaración SQL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select status,temperature from root.ln.wf01.wt01 where time &gt; 2017-11-01T00:05:00.000 and time &lt; 2017-11-01T00:12:00.000 limit 13.1</code></pre>
</div>
</div>
<div class="paragraph">
<p>La declaración SQL no se ejecutará y el mensaje de error correspondiente se proporciona de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Msg: 401: line 1:129 mismatched input '.' expecting {&lt;EOF&gt;, SLIMIT, OFFSET, SOFFSET, GROUP, DISABLE, ALIGN}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el parámetro OFFSET de la cláusula LIMIT excede el tamaño del conjunto de resultados, IoTDB devolverá un conjunto de resultados vacío. Por ejemplo, ejecutando la siguiente declaración SQL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select status,temperature from root.ln.wf01.wt01 where time &gt; 2017-11-01T00:05:00.000 and time &lt; 2017-11-01T00:12:00.000 limit 2 offset 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>El resultado se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>+----+------------------------+-----------------------------+
|Time|root.ln.wf01.wt01.status|root.ln.wf01.wt01.temperature|
+----+------------------------+-----------------------------+
+----+------------------------+-----------------------------+
Empty set.
It costs 0.005s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si el parámetro SOFFSET de la cláusula SLIMIT no es menor que el número de series temporales disponibles, el sistema muestra errores. Por ejemplo, ejecutando la siguiente declaración SQL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>select * from root.ln.wf01.wt01 where time &gt; 2017-11-01T00:05:00.000 and time &lt; 2017-11-01T00:12:00.000 slimit 1 soffset 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>La declaración SQL no se ejecutará y el mensaje de error correspondiente se proporciona de la siguiente manera:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>Msg: 411: Meet error in query process: The value of SOFFSET (2) is equal to or exceeds the number of sequences (2) that can actually be returned.</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_delete"><a class="anchor" href="#_delete"></a>DELETE</h3>
<div class="paragraph">
<p>Los usuarios pueden eliminar los datos que cumplen la condición de eliminación en la serie temporal especificada mediante la [declaración DELETE]. Al eliminar datos, los usuarios pueden seleccionar una o más rutas de series temporales, rutas de prefijos o rutas con estrella para eliminar datos dentro de un cierto intervalo de tiempo.</p>
</div>
<div class="paragraph">
<p>En un entorno de programación JAVA, puede utilizar [Java JDBC] para ejecutar sentencias UPDATE únicas o por lotes.</p>
</div>
<div class="sect3">
<h4 id="_eliminar_series_temporales_únicas"><a class="anchor" href="#_eliminar_series_temporales_únicas"></a>Eliminar Series Temporales Únicas</h4>
<div class="paragraph">
<p>Tomando ln Group como ejemplo, existe un escenario de uso de este tipo:</p>
</div>
<div class="paragraph">
<p>El dispositivo wt02 de la planta wf02 tiene muchos segmentos de errores en el estado de su fuente de alimentación antes de 2017-11-01 16:26:00, y los datos no se pueden analizar correctamente. Los datos erróneos afectaron el análisis de correlación con otros dispositivos. En este punto, los datos anteriores a este momento deben eliminarse. La declaración SQL para esta operación es</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>delete from root.ln.wf02.wt02.status where time&lt;=2017-11-01T16:26:00;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En caso de que esperemos simplemente eliminar los datos antes de 2017-11-01 16:26:00 en el año de 2017, la declaración SQL es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>delete from root.ln.wf02.wt02.status where time&gt;=2017-01-01T00:00:00 and time&lt;=2017-11-01T16:26:00;</code></pre>
</div>
</div>
<div class="paragraph">
<p>IoTDB admite la eliminación de un rango de puntos de series temporales. Los usuarios pueden escribir expresiones SQL de la siguiente manera para especificar el intervalo de eliminación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>delete from root.ln.wf02.wt02.status where time &lt; 10
delete from root.ln.wf02.wt02.status where time &lt;= 10
delete from root.ln.wf02.wt02.status where time &lt; 20 and time &gt; 10
delete from root.ln.wf02.wt02.status where time &lt;= 20 and time &gt;= 10
delete from root.ln.wf02.wt02.status where time &gt; 20
delete from root.ln.wf02.wt02.status where time &gt;= 20
delete from root.ln.wf02.wt02.status where time = 20</code></pre>
</div>
</div>
<div class="paragraph">
<p>Preste atención a que los intervalos múltiples conectados por la expresión "OR" no son compatibles con la declaración delete:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>delete from root.ln.wf02.wt02.status where time &gt; 4 or time &lt; 0
Msg: 303: Check metadata error: For delete statement, where clause can only contain atomic
expressions like : time &gt; XXX, time &lt;= XXX, or two atomic expressions connected by 'AND'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Si no se especifica una cláusula "where" en una declaración delete, se eliminarán todos los datos de una serie temporal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>delete from root.ln.wf02.status</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eliminar_varias_series_temporales"><a class="anchor" href="#_eliminar_varias_series_temporales"></a>Eliminar Varias Series Temporales</h4>
<div class="paragraph">
<p>Si es necesario eliminar tanto el estado de la fuente de alimentación como la versión de hardware del dispositivo wt02 de la planta del grupo ln wf02 antes de 2017-11-01 16:26:00, se puede utilizar [la ruta del prefijo con un significado más amplio o la ruta con la estrella] para eliminar los datos. La declaración SQL para esta operación es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>delete from root.ln.wf02.wt02 where time &lt;= 2017-11-01T16:26:00;</code></pre>
</div>
</div>
<div class="paragraph">
<p>o</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>delete from root.ln.wf02.wt02.* where time &lt;= 2017-11-01T16:26:00;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cabe señalar que cuando la ruta eliminada no existe, IoTDB dará el mensaje de error correspondiente como se muestra a continuación:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>IoTDB&gt; delete from root.ln.wf03.wt02.status where time &lt; now()
Msg: TimeSeries does not exist and its data cannot be deleted</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_eliminar_partición_de_tiempo_experimental"><a class="anchor" href="#_eliminar_partición_de_tiempo_experimental"></a>Eliminar Partición de Tiempo (experimental)</h4>
<div class="paragraph">
<p>Puede eliminar todos los datos en una partición de tiempo de un grupo de almacenamiento utilizando la siguiente gramática:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>DELETE PARTITION root.ln 0,1,2</code></pre>
</div>
</div>
<div class="paragraph">
<p>El <code>0,1,2</code> anterior es la identificación de la partición que se eliminará, puede encontrarla en las carpetas de datos de IoTDB o convertir una marca de tiempo manualmente en una identificación usando timestamp`/<code>partitionInterval</code> (piso), y <code>partitionInterval</code> debe estar en su configuración (si la partición de tiempo es compatible con su versión).</p>
</div>
<div class="paragraph">
<p>Tenga en cuenta que esta función es experimental y principalmente para el desarrollo, utilícela con cuidado.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>Esta página fue hecha usando la interfaz predeterminada de Antora.</p>
  <p>El código de esta interfaz está licenciado bajo los términos de la licencia MPL-2.0.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
